## 10.3 실행 계획 분석

실행 계획의 출력 포맷보다는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 더 중요하다.

아무런 옵션 없이 EXPLAIN 명령을 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 1줄 이상의 결과가 표시된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록 (id 값이 작을수록) 쿼리의 바깥 (Outer) 부분이거나 먼저 접근한 테이블이다.

### 10.3.1 id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.

하나의 SELECT문에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획의 레코드가 출력되지만, 같은 id 값이 부여된다.

여기서 한 가지 주의해야 할 것은 **실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지는 않는다**는 것이다.

### 10.3.2 select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. `select_type` 칼럼에 표시될 수 있는 값은 다음과 같다.

- **SIMPLE**
  UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 `select_type` 은 SIMPLE로 표시된다. (쿼리에 조인이 포함된 경우도 마찬가지)
  쿼리 문장이 아무리 복잡하더라도 **실행계획에서 `select_type` 이 SIMPLE인 단위 쿼리는 단 하나만 존재**한다. 일반적으로 가장 바깥 SELECT 쿼리의 `select_type`이 SIMPLE로 표시된다.
- **PRIMARY**
  UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽 (Outer)에 있는 단위 쿼리는 `select_type` 이 PRIMARY로 표시된다.
  SIMPLE과 마찬가지로 **`select_type` 이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재**하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.
- **UNION**
  UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 **두 번째 이후 단위 SELECT 쿼리의 `select_type` 은 UNION으로 표시**된다.
  첫 번째 단위 SELECT는 `select_type` 이 UNION되는 쿼리 결과들을 모아서 저장하는 임시테이블 (DERIVED)로 표시된다.
- **DEPENDENT UNION**
  UNION `select_type`과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에 표시되며, DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
- **UNION RESULT**
  UNION 결과를 담아두는 테이블을 의미한다.
  MySQL 8.0 이전 버전에서는 UNION과 UNION ALL의 결과를 임시 테이블로 생성했지만, 8.0부터 UNION ALL은 임시 테이블을 사용하지 않도록 기능이 개선되었다. UNION은 여전히 임시 테이블에 결과를 버퍼링한다.
  **이 임시 테이블을 가리키는 라인의 `select_type` 이 UNION RESULT다.**
  UNION RESULT는 실체 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id값은 부여되지 않는다.
- **SUBQUERY**
  `select_type` 의 SUBQUERY는 FROM절 이외에서 사용되는 서브쿼리만을 의미한다.
  실행 계획에서 **FROM절에 사용된 서브쿼리는 `select_type` 이 DERIVED**로 표시되고, **그밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY**로 표시된다.
  ```java
  사용 위치에 따른 서브쿼리 이름
  - Nested Query: SELECT절에 사용된 서브쿼리
  - Subquery: WHERE절에 사용된 서브쿼리
  - Derived Table: FROM절에 사용된 서브쿼리를 MySQL에서는 파생 테이블이라고 하며, 일반적으로 RDBMS에서는 Inline View 또는 Sub Select라고 부른다.

  반환하는 값의 특성에 따른 서브쿼리 구분
  - Scalar Subquery: 하나의 값만 반환하는 쿼리 (칼럼이 단 하나인 레코드 한 건)
  - Row Subquery: 칼럼의 개수와 관계 없이 하나의 레코드만 만환하는 쿼리
  ```
- **DEPENDENT SUBQUERY**
  서브쿼리가 **바깥쪽 (Outer) SELECT 쿼리에서 정의된 칼럼을 사용하는 경우**, `select_type` 에 DEPENDENT SUBQUERY라고 표시된다.
  DEPENDENT UNION과 같이 외부 쿼리가 먼저 수행된 후 내부 쿼리 (서브쿼리)가 실행돼야 하므로 DEPENDENT가 없는 일반 서브쿼리보다 처리 속도가 느릴 때가 많다.
- **DERIVED**
  DERIVED는 **단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것**을 의미한다.
  MySQL 5.6 버전부터는 옵티마이저 옵션 (`optimizer_switch`)에 따라 FROM절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행되기도 한다. 또한 5.6버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.
  ```java
  쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 칼럼의 값이 DERIVED인 것이 있느지 확인해야 한다. **서브쿼리를 조인으로 해결할 수 있는 경우라면 서브쿼리보다는 조인을 사용할 것을 강력히 권장한다.**
  단계적으로 서브쿼리를 추가해갸며 개발한다면 생산성은 높겠지만 쿼리의 성능은 떨어진다.
  ```
- **DEPENDENT DERIVED**
  MySQL 8.0 이전 버전에서는 FROM절의 서브쿼리는 외부 칼럼을 사용할 수 없었는데, 8.0 버전부터는 LATERAL JOIN 기능이 추가되면서 FROM절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됐다.
  `select_type` 칼럼의 DEPENDENT DERIVED 키워드는 **해당 테이블이 레터럴 조인으로 사용된 것을 의미**한다.
- **UNCACHEABLE SUBQUERY**
  하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다. 그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 캐싱하여 다시 사용할 수 있다.
  서브쿼리에 보함된 요소에 의해 **캐시 자체가 불가능할 경우** `select_type`이 UNCACHEABLE SUBQUERY로 표시된다.
  캐시를 사용하지 못하게 하는 요소로는 대표적으로 다음과 같은 것들이 있다.
  - 사용자 변수가 서브쿼리에 사용된 경우
  - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
  - UUID()나 RAND()와 같이 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우
- **UNCACHEABLE UNION**
  UNION과 UNCACHEABLE 두 키워드의 속성이 혼합된 `selected_type` 을 의미한다.
- **MATERIALIZED**
  MySQL 5.6 버전부터 도입된 `select_type` 으로, 주로 **FROM절이나 IN (subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용**된다.
  이전까지는 테이블을 읽고 테이블의 레코드마다 다른 테이블을 읽는 서브쿼리가 실행되었다면 5.7버전부터는 서브쿼리의 내용을 **임시 테이블로 구체화 (Meterialization)한 후 임시 테이블과 테이블을 조인**하는 형태로 최적화되어 처리될 수 있다.

### 10.3.3 table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.

### 10.3.4 partitions 칼럼

MySQL 5.7 버전까지는 옵티마이저가 사용하는 파티션들의 목록을 EXPLAIN PARTITION 명령을 이용해 확인 가능했지만 **8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인할 수 있게** 변경됐다.

파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝 (Partition pruning)**이라고 한다.

MySQL을 포함한 대부분의 RDBMS에서 지원하는 **파티션은 물리적으로** 개별 테이블처럼 **별도의 저장 공간**을 가진다.

### 10.3.5 type 칼럼

쿼리의 실행 계획에서 `type` 이후의 칼럼은 MySQL **서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지**를 나타낸다. (인덱스를 사용해 레코드를 읽었는지, 풀 테이블 스캔으로 읽었는지 등)

MySQL은 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리하며, MySQL의 매뉴얼에서는 `type` 칼럼을 ‘조인 타입’으로 소개한다. 하지만 조인과 관계 없이 **각 테이블의 접근 방법 (Access Type)**으로 해석하면 된다.

실행 계획의 `type` 칼럼에 표시될 수 있는 값은 현재 많이 사용되는 대부분의 버전에서 거의 차이 없이 다음과 같이 표시된다. 아래 12개 접근 방법 중 ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.

**하나의 단위 SELECT 쿼리는 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외의 `type`에서는 인덱스 항목에도 하나의 인덱스 이름만 표시된다.**

- **system**
  **레코드가 한 건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조**하는 형태의 접근 방법
  **InnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법**이다. system으로 접근한 테이블을 innodb 엔진을 사용해서 반환하도록 하면 type 칼럼이 ALL 또는 index로 표시될 가능성이 크다.
  system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 방법이므로 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.
- **const**
  테이블의 레코드 건수와 관계없이 쿼리가 **PK나 UNIQUE KEY 칼럼을 이용해 동등 조건을 가진 WHERE 조건절**을 가지고 있고, **반드시 1건의 결과를 반환**하는 쿼리의 처리 방식을 const라고 한다. 다른 DBMS에서는 이를 **UNIQUE INDEX SCAN**이라고도 표현한다.
  PK의 일부만 조건으로 사용할 때는 type 칼럼에 const가 아닌 ref로 표시된다.
- **eq_ref**
  여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
  조인에서 **처음 읽은 테이블의 칼럼 값을 그 다음 읽어야할 테이블의 PK나 UNIQUE KEY 칼럼 동등 조건 검색에 사용할 때**를 eq_ref라고 한다. 또한, 조인에서 **두 번째 이후에 읽는 테이블에서 반드시 1건만 결과가 존재**한다는 보장이 있어야 사용할 수 있는 접근 방법이다.
- **ref**
  ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, PK나 UNIQUE KEY 등의 제약조건도 없다. **인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용**된다.
  ref타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나이다.

```java
cosnt, eq_ref, ref 모두 매우 좋은 접근 방법으로 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 접근 방법이다. 쿼리를 튜닝할 때도 이 세 가지 접근 방법에 대해서는 크게 신경 쓰지 않고 넘어가도 무방하다.

**현재 나오는 type의 순서가 일반적인 처리 성능순이기는 하지만 실제 데이터의 분포나 레코드의 건수에 따라 성능 순서는 달라질 수 있다.**
```

- **fulltext**
  MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근방법을 의미한다.
  전문 검색 인덱스는 통계 정보가 관리되지 않으며, 전문 검색 인덱스를 사용하려면 전혀 다른 SQL 문법을 사용해야 한다.
- **ref_or_null**
  이 접근 방법은 ref 접근 방법에 NULL 비교가 추가된 방식이다.
  실제 업무에서 많이 활용되지 않지만 만약 사용된다면 나쁘지 않은 접근 방법 정도로 기억해 두면 충분하다.
- **unique_subquery**
  WHERE 조건절에서 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방법이다. 의미 그대로 **서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때** 이 접근 방법을 사용한다.
- **index_subquery**
  업무 특성상 IN (subquery)에서 subquery가 중복된 값을 반환할 수도 있다. 이때 **서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때** index_subquery 접근 방법이 사용된다.
- **range**
  우리가 알고 있는 **인덱스 레인지 스캔 형태의 접근 방법**이다. 일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데, MySQL 서버가 사용하는 접근 방법 중 상당히 우선순위가 낮다.
  얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 range 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.
- **index_merge**
  다른 접근 방법과는 달리 **2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리**하는 방식이다.
  하지만 index_merge 접근 방법이 사용되는 경우를 생각해보면 이름만큼 그렇게 효율적으로 작동하는 것은 아니다. index_merge 접근 방법에는 다음과 같은 특징이 있다.
  - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
  - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다.
  - index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.
- **index**
  index 접근 방법은 **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔**을 의미한다. range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것이 아니다.
  테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다. 하지만 **인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효울적**이라고 할 수 있다.
  index 접근 방법은 다음 조건 중 첫 번째 + 택 1 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.
  - (필수) range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
  - (선택) 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)
  - (선택) 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)
- **ALL**
  **풀 테이블 스캔**을 의미하는 접근 방법이다. 테이블을 처음부터 끝까지 전부 읽어서 조건에 맞지 않는 불필요한 레코드를 제거하고 반환한다.
  풀 테이블 스캔은 지금까지의 방법들로 처리할 수 없을 때 **가장 마지막에 선택하는 가장 비효율적인 방법**이다.

### 10.3.6 possible_key 칼럼

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다.

possible_keys 칼럼에 있는 내용은 **옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록**이다.

실제로 실행 계획을 보면 그 테이블의 모든 인덱스가 목록에 포함되어 나오는 경우가 허다하기 때문에 쿼리를 튜닝하는 데 크게 도움이 되지는 않는다. 그래서 실행 계획을 확인 할 때는 possible_keys 칼럼은 특별한 경우를 제외하고는 그냥 무시해도 된다.

### 10.3.7 key 칼럼

key 칼럼에 표시되는 인덱스는 **최종 선택된 실행 계획에서 사용하는 인덱스**를 의미한다. 그러므로 쿼리를 튜닝할 때는 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

실행 계획의 type 칼럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다. 실행 계획의 type이 ALL일 때와 같이 인덱스를 전혀 사용하지 못하면 key 칼럼은 NULL로 표시된다.

```java
PK는 별도의 이름을 부여할 수 없으며 기본적으로 PRIMARY라는 이르믈 가진다.
그 밖의 나머지 인덱스는 모두 테이블이나 인덱스를 생성할 때 이름을 부여할 수 있다.
```

### 10.3.8 key_len 칼럼

`key_len` 칼럼은 많은 사용자가 쉽게 무시하는 정보지만 사실은 매우 중요한 정보 중 하나다.

실행 계획의 `key_len` 칼럼의 값은 **쿼리를 처리하기 위해** 다중 칼럼으로 구성된 인덱스에서 몇 개, 더 정확하게는 **인덱스의 각 레코드에서 몇 바이트까지 사용했는지** 알려주는 값이다. 다중 칼럼 인덱스 뿐 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공한다.

실제 utf8mb4 문자 집합에서 문자 하나가 차지하는 공간은 1바이트에서 4바이트까지 가변적이다. 하지만 MySQL 서버가 utf8mb4 문자를 위해 메모리 공간을 할당해야 할 때는 문자와 관계 없이 고정적으로 4바이트로 계산한다.

### 10.3.9 ref 칼럼

**접근 방법이 ref인 경우 equal 비교 조건으로 어떤 값이 제공됐는지** 보여준다.

상수값을 저장했다면 ref 칼럼의 값은 cosnt로 표시되고, 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.

### 10.3.10 rows 칼럼

MySQL 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행계획을 수립한다. 이때 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해애 하는지 예측해서 비용을 산정한다.

실행 계획의 `rows` 칼럼 값은 실행 계획의 효율성 판단을 위해 **예측했던 레코드 건수**를 보여준다. 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해낸 예상값이라서 정확하지는 않다.

`rows` 칼럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라 **쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지**를 의미한다.

### 10.3.11 filtered 칼럼

실행 계획에서 `rows` 칼럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측한 것이다. 하지만 대부분 쿼리에서 WHERE절에 사용되는 조건이 모두 인덱스를 사용할 수 있는 것은 아니다.

filtered 칼럼의 값은 **필터링되고 남은 레코드의 비율**을 의미한다.

옵티마이저는 레코드 건수 뿐만 아니라 다른 요소들도 충분히 감안해서 실행 계획을 수립하겠지만 조인의 횟수를 줄이고 그 과정에서 읽어온 데이터를 저장해둘 메모리 사용량을 낮추기 위해 대상 건수가 적은 테이블을 선행 테이블로 선택할 가능성이 높다.

### 10.3.12 Extra 칼럼

칼럼의 이름과는 달리, 쿼리의 실행 계획에서 성능에 관련된 중요한 내용으 `Extra` 칼럼에 자주 표시된다.

`Extra` 칼럼에는 고정된 몇 개의 문장이 표시되는데, 일반적으로 2 ~ 3개씩 함께 표시된다. 주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많다.

다음은 `Extra` 칼럼에 표시될 수 있는 문장들로, 순서는 성능과 무관하다.

- **const row not found**: `const` 타입의 테이블에서 조건에 맞는 행이 아예 없음 (조기 종료 가능).
- **Deleting all rows**: 모든 행을 삭제하는 쿼리로 판단됨.
- **Distinct**: 중복 제거(`DISTINCT`)를 위해 고유한 값만 추출하는 작업을 수행.
- **Select tables optimized away**: 불필요한 테이블 조회가 제거됨 (최적화).
- **FirstMatch**: 조인을 할 때, 첫 번째 일치하는 값만 찾고 다음으로 넘어감 (최적화).
- **Impossible HAVING**: `HAVING` 조건이 절대 참이 될 수 없음 → 결과 없음.
- **Impossible WHERE**: `WHERE` 조건이 절대 참이 될 수 없음 → 결과 없음.
- **No matching min/max row**: `MIN()` 또는 `MAX()` 조건에 맞는 값이 없음.
- **no matching row in const table**: 상수 테이블에서 조건에 맞는 행 없음 → 쿼리 실패 예상.
- **Nomatching rows after partition pruning**: 파티션 필터링 이후에도 남는 행 없음.
- **No tables used**: 테이블을 사용하지 않는 쿼리 (예: `SELECT 1+1`).
- **Not exists**: `NOT EXISTS` 서브쿼리 최적화 수행됨.
- **unique row not found**: `UPDATE`, `DELETE` 시 대상이 되는 고유 행을 찾지 못함.
- **Zero limit**: `LIMIT 0`이라 결과가 필요 없음 → 실제 조회 없음.
- **Full scan on NULL key**: `NULL` 값 때문에 인덱스를 사용할 수 없어 전체 스캔 수행.
- **Range checked for each record (index map: N)**: 조인 시 인덱스 범위를 각 행마다 다시 계산.
- **Recursive**: Common Table Expression (CTE) 같은 재귀적 쿼리 사용.
- **Rematerialize**: 동일 서브쿼리를 반복해서 다시 계산.
- **Plan isn’t ready yet**: 실행 계획이 아직 완성되지 않음 (준비 안 됨).
- **Using index**: 쿼리 결과가 인덱스만으로 해결됨 (커버링 인덱스).
- **Using index condition**: 인덱스를 이용한 조건 필터링 (Index Condition Pushdown).
- **Using index for group-by**: 인덱스를 활용한 `GROUP BY` 최적화.
- **Using index for skip scan**: 좌측 컬럼이 없는 인덱스를 우회적으로 활용 (skip scan).
- **LooseScan**: 인덱스를 느슨하게 스캔 (`GROUP BY`에 유리).
- **타이트 인덱스 스캔을 통한 GROUP BY 처리**: 인덱스를 정확하게 따라가며 그룹핑.
- **루스 인덱스 스캔을 통한 GROUP BY 처리**: 인덱스를 느슨하게 따라가며 그룹핑.
- **Using filesort**: 메모리나 디스크에 결과를 정렬 (인덱스 미사용).
- **Using temporary**: 결과를 임시 테이블에 저장 (GROUP BY, ORDER BY 등에서 자주 발생).
- **Start temporary, End temporary**: 임시 테이블 생성과 해제를 명시적으로 표시.
- **Using where**: `WHERE` 조건절이 사용되었음을 의미.
- **Using join buffer**: 인덱스가 없어 조인 버퍼를 사용한 조인 수행.
  - Block Nested Loop / Batched Key Access / Hash Join 등 다양한 방식 존재.
- **Using MRR (Multi-Range Read)**: 인덱스를 묶어서 효율적으로 읽음.
- **Using sort_union(...)**, **Using union(...)**, **Using intersect(...)**: 여러 인덱스 결과를 병합하거나 교차하여 사용.
