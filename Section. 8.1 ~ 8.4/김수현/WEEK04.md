# Real MySQL 8.1 ~ 8.4

# 8.1 디스크 읽기 방식

- Intro
  - 데어터 저장 매체 : 컴퓨터에서 가장 느린 부분 ex) 하드 디스크, SSD 드라이브 → 데이터베이스의 성능 튜닝 = 디스크 I/O 줄이기
- 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
  - SSD의 장점 : 기존의 HDD보다 랜덤 I/O 속도가 훨씬 빠름 → DB에서 순차 I/O 작업 비중보다 랜덤 I/O의 비중이 대부분이다. 따라서 SSD의 장점은 DBMS 스토리지에 최적
    cf) 랜덤 I/O vs 순차 I/O
    | 항목             | 순차 I/O                           | 랜덤 I/O                 |
    | ---------------- | ---------------------------------- | ------------------------ |
    | 데이터 접근 방식 | 연속적 접근                        | 임의 위치 접근           |
    | 속도             | 빠름                               | 느림                     |
    | 주요 성능 지표   | 처리량(Throughput)                 | IOPS(초당 입출력 횟수)   |
    | HDD 성능         | 우수                               | 매우 낮음                |
    | SSD 성능         | 매우 우수                          | 우수(HDD 대비 뛰어남)    |
    | 적합한 서비스    | 대용량 데이터 처리, 백업, 스트리밍 | DB 트랜잭션, 실시간 응답 |
- 8.1.2 랜덤 I/O와 순차 I/O
  - 디스크 성능 : 데스크 헤더 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정 → 여러 번 쓰기 혹은 읽기 ㅛ청하는 랜덤 I/O 작업이 작업 부하가 훨씬 크다.
  - 순차 I/O
    - 정의 : 데이터를 연속된 주소에서 순서대로 읽거나 쓰는 방식
    - 특징
      1. 하드디스크 및 SSD에서 읽기/쓰기 성능 빠름
      2. 디스크 헤드 이동이 최소화되어 데이터 접근 시간 빠름
      3. 대용량 파일 처리 시 유리
    - 장점
      1. 속도가 빠르고 처리량 높음
      2. 대용량 파일 백업, 동영상 스트리밍, 데이터베이스의 전체 테이블 스캔 등에서 효율적
    - 단점
      1. 특정 데이터만 찾거나 업데이트할 시에 효율이 낮음
    - 활용 예시 : 데이터 백업, 로그 파일 쓰기, 동영상 재생, 빅데이터 배치 작업
  - 랜덤 I/O
    - 정의 : 데이터가 디스크의 여러 위치에 흩어져 순서 없이 임의 위치에서 데이터 읽거나 쓰는 방식
    - 특징
      1. 디스크 헤드 이동이 많아 데이터 접근 지연 발생
      2. 특히 HDD에서 랜덤 IO 성능이 크게 떨어짐
      3. SSD는 랜덤 IO에 상대적으로 강하지만 순차 IO보다는 느
    - 장점
      1. 특정 데이터를 빠르게 찾아 접근할 수 있는 장점이 있어 빠른 응답 속도를 요구하는 서비스에 적합
    - 단점
      1. 데이터 접근 성능이 떨어지고 IOPS(초당 입출력 처리 횟수)가 낮아질 수 있음
      2. HDD의 경우 성능 저하가 매우 큼
    - 활용 예시 : 데이터베이스 트랜잭션 처리, 웹 서비스 응답 처리, 운영체제의 페이징 작업, OLTP 시스템

# 8.2 인덱스란?

- Intro
  - 책의 ‘찾아보기’와 같은 결 → 컬럼의 값을 주어진 순서대로 미리 정렬
  - SortedList vs ArrayList
    - SortedList : DBMS의 인덱스와 같은 자료 구조, 저장된 값을 항상 정렬된 상태로 유지 → 데이터 저장될 때마다 정렬이 일어나므로 저장 과정 복잡 But 정렬되어 있으므로 조회 빠름 (Insert, Update, Delete 기능 희생하고 Select 기능을 극대화)
    - ArrayList : 데이터 파일과 같은 자료 구조, 별도의 정렬없이 그대로 저장
  - 프라이머리 키 vs 보조(세컨더리) 키 (단 키 = 인덱스)
    - 프라이머리 키 : 레코드를 대표하는 칼럼의 값으로 만들어지는 인덱스, 레모드를 식별하는 기준 값이 되므로 식별자라고 부름(Not Null, 중복 X)
    - 보조 키 : 프라이머리 키 제외한 모든 인덱스, 유니크 인덱스는 프라이머리 키와 비슷하고 대체 가능하므로 대체 키라고 불리기도 한다.
  - B-Tree 알고리즘 vs Hash 인덱스 알고리즘
    - B-Tree : 가장 일반적인 인덱스 알고리즘, 칼럼의 값 변형하지 않고 원래의 값 이용해 인덱싱
    - Hash 인덱스 알고리즘 : 칼럼의 값으로 해시값을 계산해 인덱싱하는 알고리즘, 매운 빠른 검색 지원 But 전방일치(문자열%) 같이 일부 혹은 범위(Between) 검색 시 사용 불가

# 8.3 B-Tree 인덱스

- Intro
  - B-Tree(Balanced Tree) : 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태 유지
- 8.3.1 구조 및 특성

  - 루트 노드(Root Node) : 트리 구조의 최상위 노드
  - 리프 노드(Leaf Node) : 트리 구조의 최하위 노드
  - 브랜치 노드(Branch Node) : 트리 구조에서 루트도 아니고 리프도 아닌 중간의 노드
  - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값 보유
  - 인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬되 있지 않고 임의의 순서대로 저장 → 레코드가 삭제되어 빈공간 생긴 경우 그 위치를 재활용하기 때문
  - MyISAM vs InnoDB
    - MyISAM : 세컨더리 인덱스가 물리적인 주소를 갖는다. → 데이터 파일을 바로 찾아감
    - InnoDB : 세컨더리 인덱스가 논리적인 주소를 갖는다.(프라이머리 키를 주소처럼 사용) → 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드 읽는다. 즉 세컨더리 인덱스 검색에서 데이터 레코드 읽기 위해 프라이머리 키를 저장한 B-Tree를 다시 한 번 검색

- 8.3.2 B-Tree 인덱스 키 추가 및 삭제
  - 8.3.2.1 인덱스 키 추가 : 저장될 키 값 활용해 B-Tree 상의 적절한 위치 검색 → 위치 결정 시 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장
    - if 저장할 리프 노드가 꽉 찬 경우 → 리프 노드 분리(Split) → 상위 브랜치 노드까지 처리 범위 넓어짐 → 상대적으로 쓰기 작업에 많은 비용 소모
  - 8.3.2.2 인덱스 키 삭제 : 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크 → 삭제 마킹된 인덱스 키 공간은 그대로 방치 or 재활용(마킹 작업 또한 디스크 쓰기 필요하므로 디스크 I/O 발생)
  - 8.3.2.3 인덱스 키 변경 : 키 값 삭제한 후 다시 새로운 키 값을 추가하는 형태 → 키 값 변경 떄문에 발생하는 B-Tree 인덱스 키 삭제와 추가 작업은 앞에 기술한 절차대로 처리
  - 8.3.2.4 인덱스 키 검색
    - 트리 탐색 : B-Tree 루트 노드 → 브랜치 노드 → 리프 노드 비교 작업 수행
    - 인덱스 이용한 검색 : 100% 일치 or 값의 앞부분(Left-most part)만 일치하는 경우에 사용
      - 부등호 비교 조건에서 인덱스 활용 가능 But 인덱스 구성하는 키의 뒷부분만 검색하는 용도로는 인덱스 활용X
      - 인덱스 키 값에 변형이 가해진 후 비교되는 경우 인덱스 키 검색 활용 X → 함수나 연산을 수행한 결과 정렬하거나 검색하는 작업은 B-Tree 장점 활용 X
    - InnoDB에서 지원하는 레코드 잠금 혹은 넥스트 키락이 검색 수행한 인덱스 잠근 후 테이블의 레코드 잠금 → 따라서 InnoDB에서 UPDATE, DELETE 실행 시 불필요하게 많은 레코드 잠금(최악의 경우 모든 레코드 잠금)
- 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
  - 8.3.3.1 인덱스 키 값의 크기
    - 페이지(Page) 또는 블록(Block) : 디스크에 데이터를 저장하는 기본 단위(디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위), 또한 페이즈는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터 버퍼링하는 기본 단위
    - B-Tree 자식 노드의 갯수가 가변적 : 자식 노드의 수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정 → 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽는 횟수 증가하며 느려짐 & 인덱스 키 값의 길이 길어짐 → 전체적인 인덱스의 크기가 커짐 But InnnoDB 버퍼풀이나 MyISAM의 키 캐시 영역(인덱스 캐시해두는 장소) 제한적이므로 인덱스의 크기 커지면 캐시하는 레코드 수 감소(메모율 효율 감소)
  - 8.3.3.2 B-Tree 깊이
    - MySQL에서 값을 검색할 때 몇 번이나 램덤하게 디스크를 읽어야하는가와 직격 → 인덱스의 키 값 커질수록 하나의 인덱스 페이지에 담을수 있는 인덱스 키 값의 갯수 감소 → B-Tree 깊이가 깊어져 디스크 읽기가 더 많이 필요
  - 8.3.3.3 선택도(기수성)
    - 의미 : 모든 인덱스 키 값 가운데 유니크한 값의 수 → 선택도가 높을 수록 검색 대상이 줄어들기 때문에 빠르게 처리
  - 8.3.3.4 읽어야하는 레코드의 건수
    - 인덱스 통해 테이블 레코드 읽는 비용 > 인덱스 거치지 않고 바로 테이블 레코드 읽는 비용 → 인덱스를 이용한 손익 분기점 파악이 중요
    - 인덱스 통한 비용 레코드 1건 읽는 비용 = 테이블에서 직접 레코드 읽는 비용 \* 4~5 (By 옵티마이저) → 인덱스 통해 읽어야할 레코드의 건수가 전체 테이블의 20 ~ 25%를 넘어서면 인덱스 이용하지 않고 테이블 모두 직접 읽는 것이 효율적
- 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
  - 8.3.4.1 인덱스 레인지 스캔(Index Range Scan)
    - 정의 : 검색해야 할 인덱스의 범위가 결정될 시에 사용하는 방식(검색하려는 값의 수나 검색 결과 레코드 건수와 관계업싱 레인지 스캔으로 표현)
    - 루트 노드부터 시작해 최종적으로 리프 노드에 도달해야만 필요한 레코드의 시작 지점 찾을 수 있다. → 시작 위치 찾은 이후 리프 노드의 레코드만 순서대로 읽는다. 만약 리포 노드의 끝까지 읽으면 리프 노드 간의 링크로 다음 리프 노드를 찾아서 다시 스캔 → 최종적으로 스캔 멈출 위치에서 지금까지 읽은 레코드 사용자에게 반환
    - B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드 읽는 경우 : 리프 노드에 저장된 레코드 주소로 데이터 파일에 레코드를 읽는데 건수마다 랜덤 I/O가 발생 → 인덱스를 통해 데이터 레코드 읽는 작업은 비용이 많이 드는 작업(읽어야할 레코드가 전체의 20 ~ 25% 이상이면 테이블 전체 데이터를 읽는 것이 더 효율적)
    - 인덱스 레인지 스캔 단계
      1. 인덱스에서 조건 만족하는 값이 저장된 위치 찾는다(인덱스 탐색)
      2. 1번에서 탐색된 위치로부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.(인덱스 스캔)
      3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어 온다.
    - 쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수 있다 = 커버링 인덱스
  - 8.3.4.2 인덱스 풀 스캔(Index Full Scan)
    - 정의 : 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식, 대표적으로 쿼리 조건절에 사용된 컬럼이 인덱스의 첫번째 칼럼이 아닌 경우 ex) 인덱스(A,B,C) 칼럼으로 구성 But 조건절은 B나 C로 검색
    - 쿼리가 인덱스에 명시된 컬럼만으로 조건 처리 가능할 경우 이 방식 사용, 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야한다면 이 방식으로 처리되지 않는다.
    - 인덱스 풀 스캔 단계
      1. 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동
      2. 인덱스의 리프 토드 연결하는 LinkedList를 따라서 처음부터 끝까지 스캔
    - 인덱스 레인지 스캔보다 느리지만 테이블 풀 스캔보다 효율적 → 인덱스 포함된 칼럼만으로 쿼리 처리 가능할 시 인덱스 전체의 크기가 테이블 자체의 크기보다 훨씬 작으므로 적은 디스크 I/O로 쿼리 처리
  - 8.3.4.3 루스 인덱스 스캔
    - 정의 : 인덱스 레인지 스캔과 비슷하지만 중간에 필요하지 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태, 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화하는 경우 사용
  - 8.3.4.4 인덱스 스킵 스캔
    - 정의 : 인덱스를 구성하는 칼럼들 중 쿼리 조건문이 첫번쨰 칼럼을 이용하지 않는 경우에도 필요 범위만 읽어서 최적화하는 탐색 방법
    - 단점
      1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 갯수가 적어야함 → 쿼리 실행 계획의 비용과 연관있는 부분으로 유니크한 값의 갯수가 많다면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 증가해 오히려 쿼리 처리 성능이 저해
      2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리가능해야함(커버링 인덱스)
- 8.3.5 다중 컬럼(Multi-column) 인덱스

  - 정의 : 2개 이상의 컬럼으로 구성된 인덱스
  - 정렬 순서 : 첫번쨰 컬럼 순으로 정렬 → 두번째 컬럼은 첫번쨰 컬럼에 의존해서 정렬 → … → N번쨰 컬럼은 N-1번쨰 컬럼에 의존해서 정렬

- 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

  - 인덱스 생성 시 정렬 규칙에 따라 인덱스의 키 값은 항상 오름차순이거나 내림차순 정렬 → But 읽을 시에 오름차순으로만 읽기 가능한 것은 아니다.
  - 8.3.6.1 인덱스의 정렬 : MySQL 8.0부터 ASC, DESC를 사용해 각 인덱스 키의 정렬을 설정할 수 있으며 더 나아가 혼합 인덱스에 키 별로 ASC, DESC 설정도 가능하다
    - 인덱스 스캔 방향 : 인덱스 생성 시점에 오름차순, 내림차순으로 정렬이 결정되나 인덱스 사용 시점에 인덱스 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
      1. 오름차순 인덱스 : 작은 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
      2. 내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree 왼쪽으로 정렬된 인덱스
      3. 인덱스 정순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
      4. 인덱스 역순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
    - 인덱스 역순 스캔이 정순 스캔에 비해 느린 이유
      1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
      2. 페이지 내에서 인덱스 레코드가 단방향으로 연결된 구조

- 8.3.7 B-Tree 인덱스의 가용성과 효율성
  - 8.3.7.1 비교 조건의 종류와 효율성
    - 필터링 : 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업
    - 작업 범위 결정 조건 : 작업의 범위를 결정하는 조건
    - 필터링 조건(체크 조건) : 비교 작업의 범위를 줄이지 못하고 거름종이 역할만 수행하는 조건
    - 작업 범위 결정하는 조건이 많을수록 쿼리의 성능 높아짐 But 체크 조건이 많아진다고 쿼리의 성능이 높아지지 않는다.(오히려 쿼리 실행을 더 느리게 만들 때가 많다.)
  - 8.3.7.2 인덱스의 가용성
    - B-Tree 인덱스의 특징 : 왼쪽 값에 기준해(Left-most) 오른쪽 값이 정렬되어 있다. → 하나의 컬럼 혹은 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 예를 들어 % 와일드 카드가 문자열 좌측에 위치(%sb)하면 인덱스 레인지 스캔 방식 활용하지 못한다.
  - 8.3.7.3 가용성과 효율성 판단
    - 인덱스의 활용할 수 없는 상황
      1. NOT-EQUAL로 비교된 경우(”<>”, “NOT IN”, “NOT BETWEEN”, “IS NOT NULL”)
      2. LIKE ‘%??’ (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
      3. 스토어드 함수나 다른 연산자로 인해 인덱스 칼럼이 변형된 후 비교된 경우

         Ex) SUBSTRING(column, 1, 1) = ‘X’, DAYOFMONTH(column) = 1

      4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

         Ex) column = deterministic_function()

      5. 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교 가능한 경우)
      6. 문자열 데이터 타입의 콜렉션이 다른 경우
    - 다른 DBMBS에서 NULL 값이 인덱스에 저장X But MySQL의 경우 NULL값도 인덱스에 저장
    - INDEX ix_test( column_1, column_2, column_3, …, column_n )
      - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
        1. column_1 컬럼에 대한 조건이 없는 경우
        2. column_1 컬럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
      - 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다는 작은 임의의 값)
        1. column*1 ~ column*(i-1) 컬럼까지 동등 비교 형태(”=” 또는 “IN”)로 비교
        2. column_i 컬럼에 대해 다음 연산자 중 하나로 비교
           1. 동등 비교(”=” 또는 “IN”)
           2. 크다 작다 형태(”>” 또는 “<”)
           3. LIKE로 좌측 일치 패턴(LIKE ‘승환%’)
        → 위의 2가지 조건을 모두 만족하는 쿼리는 column*1부터 column_i까지 작업 범위 결정 조건으로 사용되고, column*(i+1)부터 column_n까지 조건은 체크 조건으로 사용

# 8.4 R-Tree 인덱스

- Intro
  - 공간 인덱스(Spatial Index) : R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스 → B-Tree와 유사 But B-Tree 인덱스 구성하는 컬럼의 값은 1차원 스칼라 값인 반면 R-Tree 인덱스는 2차원 공간 개념
  - MySQL 공간 확장 : GPS, GIS 등 위치 기반을 둔 서비스 구현에 용이
    1. 공간 데이터를 저장할 수 있는 데이터 타입
    2. 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
    3. 공간 데이터의 연산 함수(거리 또는 포함 관계 처리)
- 8.4.1 구조 및 특성
  - MySQL은 공간 정보의 저장 및 검색을 위해 기하학적 도형 관리하는 데이터 타입 제공
    1. POINT
    2. LINE
    3. POLYGON
    4. GEOMETRY(1 ~ 3의 슈퍼 타입으로 모두 저장 가능)
  - MBR(Minimum Bounding Rectangle) : 해당 도형 감싸는 최소 크기의 사각형
    - 정의 : 레코드 - 레코드 사이의 간격 잠금
    - 사용법 : 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어한다.
- 8.4.2 R-Tree 인덱스의 용도
  - R-Tree 인덱스(공간 인덱스) : WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용, 각 도형(정확히는 도형의 MBR)의 포함 관계를 이용해 만들어진 인덱스 → ST_Contains() 또는 ST_Within() 등 포함 관계를 비교하는 함수로 검색 수행하는 경우에만 사용 Ex) 현재 사용자 위치로부터 반경 5KM 이내의 음식점 검색
  - ST_Contains() 또는 ST_Within() 연산은 사각형 박스와 같은 다각형(Polygon)으로만 연산할 수 있다.(원이 아니다 주의)
  - ST_Contains(사각 상자, px) / ST_Contains(px, 사각 상자)
  - 따라서 ST_Contains, ST_Contains을 쓴다면 원이 아니라 원하는 거리에 대해서 중심점을 기준으로 원하는 거리에 대응하는 사각형을 만든다 → 이에 따라 특정 점이 거리 밖에 있어도 포함되어 출력되는 경우가 발생한다.
  - ST_Contains 비교 → 결과값을 다시 ST_Distance_Sphere()함수를 이용하면 중심점 기준으로 원하는 거리에 대응되는 원이 만들어진다. → 앞서 말한 특정 점이 거리 밖에 있어도 출력되는 경우를 방지한다.
