## 9.4 쿼리 힌트

옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려주기 위한 목적으로 힌트가 제공되며, MySQL에서도 다양한 옵티마이저 힌트를 제공한다.

MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.

- 인덱스 힌트
- 옵티마이저 힌트

### 9.4.1 인덱스 힌트

인덱스 힌트들은 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이다. SQL 문법에 맞게 사용해야 하기 때문에 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다. `SELECT` 와 `UPDATE` 명령에서만 사용할 수 있다.

MySQL 5.6 버전부터 추가되기 시작한 **옵티마이저 힌트들**은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 **주석으로 해석**하기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다.

- **STRAIGHT_JOIN**
  옵티마이저 힌트인 동시에 조인 키워드이기도 하다. `SELECT` , `UPDATE` , `DELETE` 쿼리에서 여러 개의 테이블이 조인되는 경우 **조인 순서를 고정**하는 역할을 한다.
  ex) 테이블을 조인할 때 어느 테이블이 드라이빙 테이블이 되고 어느 테이블이 드리븐 테이블이 될지 알 수 없다. 옵티마이저가 그때그때 각 테이블의 통계 정보와 쿼리의 조건을 기반으로 가장 최적이라고 판단되는 순서로 조인한다. 일반적으로 조인을 하기 위한 칼럼들의 인덱스 여부와 레코드가 적은 테이블이 드라이빙 테이블로 선택된다.
  다음의 경우 STRAIGHT_JOIN힌트를 통해 **FROM절에 명시된 테이블의 순서대로 조인을 수행하도록 유도**할 수 있다.
  ```sql
  SELECT **STRAIGHT_JOIN //** SELECT **/*! STRAIGHT_JOIN*/**
  	e.first_name, e_last_name, d.dept_name
  FROM employees e, dept_emp de, departments d
  WHERE e.emp_no = de.e-=mp_no
  	AND d.dept_no = de.dept_no;
  ```
  다음과 같이 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.
  - 임시 테이블 (인라인 뷰 또는 파생된 테이블)과 일반 테이블의 조인
    : 일반적으로 임시테이블이 드라이빙 테이블로 선정되는 것이 좋다. 조인 칼럼에 인덱스가 없는 경우 레코드 건수가 작은 쪽을 드라이빙 테이블로 선정한다.
  - 임시 테이블끼리 조인
    : 임시 테이블 (서브 쿼리로 파생된 테이블)은 항상 인덱스가 없기 때문에 그냥 크기가 작은 테이블을 드라이빙 테이블로 선택해주는 것이 좋다.
  - 일반 테이블끼리 조인
    : 양쪽 테이블 모두 조인 칼럼에 인덱스가 있거나 양쪽 테이블 모두 조인 칼럼에 인덱스가 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택해주는 것이 좋으며, 그 외에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.
  ```sql
  여기서 레코드 건 수는 테이블 전체 레코드 건 수가 아니라 WHERE 조건과 같은 조건을 모두 만족하는 레코드 건수를 말한다.
  ```
- **USE INDEX / FORCE INDEX / IGNORE INDEX**

  인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.

  인덱스 힌트는 크게 다음과 같이 3종류가 있다. 모두 키워드 뒤에 사용할 인덱스의 이름을 괄호로 묶어서 사용하며, 괄호 안이 비었거나 없는 인덱스 이름인 경우 쿼리 문법 오류로 처리된다.

  - USE INDEX
    : MySQL 옵티마이저에게 **해당 테이블의 인덱스를 사용하도록 권장**하는 힌트이다. 대부분의 경우 인덱스 힌트가 주어지면 옵티마이저는 사용자의 힌트를 채택하지만 **항상 그 인덱스를 사용하는 것은 아니다.**
  - FORCE INDEX
    : USE INDEX와 동일하지나 **옵티마이저에게 미치는 영향이 더 크다.**
    하지만 USE INDEX만으로 충분히 영향력이 크고, 대체로 USE INDEX 힌트를 부여했는데도 그 인덱스를 사용하지 않는 경우라면 FROCE INDEX 힌트를 사용해도 그 인덱스를 사용하지 않았다고 한다.
  - IGNORE INDEX
    **특정 인덱스를 사용하지 못하도록** 하는 힌트이다. 옵티마이저가 풀 테이블 스캔을 하도록 유도하는 경우 사용할 수 있다.

  위 3가지 인덱스 힌트 모두 용도를 명시해줄 수 있다. 이는 선태가항이며, 특별히 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용한다.

  - USE INDEX FOR JOIN
    : 테이블 간 조인 뿐만 아니라 MySQL 서버에서 하나의 테이블로부터 데이터를 검색하는 JOIN도 포함한다.
  - USE INDEX FOR ORDER BY
    : 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있도록 제한한다.
  - USE INDEX FOR GROUP BY
    : 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한한다.

  용도는 옵티마이저가 대부분 최적으로 선택하기 때문에 인덱스의 용도까지는 크게 고려하지 않아도 된다.

  ```sql
  SELECT * FROM employees USE INDEX(primary) WHERE emp_no=10001;
  ```

  ```sql
  인덱스의 사용법이나 좋은 실행 계획이 어떤 것인지 판단하기 힘든 상황이라면 힌트를 사용해 강제로 옵티마이저의 실행 계획에 영향을 미치는 것는 피하는 것이 좋다. 가장 좋은 실행 계획은 데이터의 성격에 따라서 시시각각 변하며 MySQL 옵티마이저는 최적화를 빠르게 처리할 수 있다.
  **가장 훌륭한 최적화는 그 쿼리를 서비스에서 없애거나 튜닝할 필요 없도록 데이터를 최소화하는 것이며, 그것이 어렵다면 데이터 모델의 단순화를 통해 쿼리를 간곃하게 만들고 힌트가 필요하지 않도록 하는 것이다.**
  ```

- **SQL_CALC_FOUND_ROWS**
  MySQL의 LIMIT을 사용하는 경우 조건을 만족하는 레코드가 더 있더라도 LIMIT에 명시돤 수만큼 만족하는 레코드를 찾으면 즉시 검색 작업을 멈춘다. 하지만 이 힌트가 포함된 쿼리의 경우 **LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행**한다.
  SQL_CALC_FOUND_ROWS 힌트가 사용된 쿼리가 실행된 경우에는 FOUND_ROWS()라는 함수를 이용해 LIMIT을 제외한 조건을 만족하는 레코드가 전체 몇 건이었는지 알아낼 수 있다.
  ```sql
  SELECT SQL_CALC_FOUND_ROWS * FROM employees WHERE first_name='Georgi' LIMIT 0,20;
  SELECT FOUND_ROWS();

  -> 조건을 만족하는 row 수만큼 랜덤 IO 발생
  ```
  ```sql
  SELECT COUNT(*) FROM employees WHERE first_name='Georgi';
  SELECT * FROM employees WHERE first_name='Georgi' LIMIT 0.20;

  -> LIMIT 제한이 있으므로 랜텀 IO 20번 발생
  ```
  웬만하면 SQL_CALC_FOUND_ROWS 힌트를 **사용하지 않는 것이 성능에 좋다.** 이 힌트는 **성능 향상을 위해 만들어진 힌트가 아니라 개발자의 편의를 위해 만들어진 힌트**이기 때문이다.

### 9.4.2 옵티마이저 힌트

MySQL 8.0 버전에서 사용 가능한 힌트는 종류가 매우 다양하며, 힌트가 미치는 영향의 범위도 다양하다.

- **옵티마이저 힌트 종류**
  옵티마이저 힌트는 영향 범위에 따라 다음 4개의 그룹으로 나누어볼 수 있다.
  - **인덱스**: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
  - **테이블**: 특정 테이블 이름을 사용할 수 있는 옵티마이저 힌트
  - **쿼리 블록**: 특정 쿼리 블록에 사용할 수 있는 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
  - **글로벌 (쿼리 전체)**: 전체 쿼리에 대해서 영향을 미치는 옵티마이저 힌트
    | 힌트 이름                      | 설명                                         | 영향 범위  |
    | ------------------------------ | -------------------------------------------- | ---------- |
    | MAX_EXECUTION_TIME             | 쿼리의 실행 시간 제한                        | 글로벌     |
    | RESOURCE_GROUP                 | 쿼리 실행의 리소스 그룹 설정                 | 글로벌     |
    | SET_VAR                        | 쿼리 실행을 위한 시스템 변수 제어            | 글로벌     |
    | SUBQUERY                       | 서브 쿼리의 세미 조인 최적화 전략 제어       |
    | (MATERIALIZATION과 INTOEXISTS) | 쿼리 블록                                    |
    | BKA,                           |
    | NO_BKA                         | BKA (Batched Key Access) 조인 사용 여부 제어 | 쿼리 블록, |
    | 테이블                         |
    | BNL,                           |
    | NO_BNL                         | (MySQL 8.0.18 이전까지)                      |
    블록 네스티드 루브 조인 (BNL) 사용 여부 제어
    (MySQL 8.0.20 부터)
    해시 조인 사용 여부 제어 | 쿼리 블록,
    테이블 |
    | DERIVED_CONDITION_PUSHDOWN,
    NO_CONDITION_PUSHDOWN | 외부 쿼리의 조건을 서브 쿼리로 옮기는 최적화 사용 여부 제어 | 쿼리 블록,
    테이블 |
    | HASH_JOIN,
    NO_HASH_JOIN | (MySQL 8.0.18만 가능)
    해시 조인 사용 여부 제어
    (MySQL 8.0.18 이후 버전에서는)
    BNL과 NO_BNL 힌트로 해시 조인 사용 여부 제어 | 쿼리 블록,
    테이블 |
    | JOIN_FIXED_ORDER | FROM절에 명시된 테이블 순서대로 조인 실행 | 쿼리 블록 |
    | JOIN_ORDER | 힌트에 명시된 테이블 순서대로 조인 실행 | 쿼리 블록 |
    | JOIN_PREFIX | 힌트에 명시된 테이블을 조인의 드라이빙 테이블로 조인 실행 | 쿼리 블록 |
    | JOIN_SUFFIX | 힌트에 명시된 테이블을 조인의 드리븐 테이블로 조인 실행 | 쿼리 블록 |
    | QB_NAME | 쿼리 블록의 이름 설정을 위한 힌트 | 쿼리 블록 |
    | SEMIJOIN,
    NO_SEMIJOIN | 서브 쿼리의 세미 조인 최적화 전략 제어
    (DUPSWEEDOUT, FIRSTMATCH, LOOSESCAN, MATERIALIZATION) | 쿼리 블록 |
    | MERGE,
    NO_MERGE | FROM절의 서브쿼리나 뷰를 외부 쿼리 블록으로 병합하는 최적화를 수행할지 여부 제어 | 테이블 |
    | INDEX_MERGE,
    NO_INDEX_MERGE | 인덱스 병합 실행 계획 사용 여부 제어 | 테이블,
    인덱스 |
    | MRR,
    NO_MRR | MRR (Multi-Range Read) 사용 여부 제어 | 테이블,
    인덱스 |
    | NO_ICP | ICP (Index Conditioin Pushdown) 최적화 전략 사용 여부 제어 | 테이블,
    인덱스 |
    | NO_RANGE_OPTIMIZATION | 인덱스 레인지 액세스를 비활성화
    (특정 인덱스를 사용하지 못하도록 하거나 쿼리를 풀 테이블 스캔 방식으로 처리) | 테이블,
    인덱스 |
    | SKIP_SCAN,
    NO_SKIP_SCAN | 인덱스 스킵 스캔 사용 여부 제어 | 테이블,
    인덱스 |
    | INDEX,
    NO_INDEX | GROUP BY, ORDER BY, WHERE 절의 처리를 위한 인덱스 사용 여부 제어 | 인덱스 |
    | GROUP_INDEX,
    NO_GROUP_INDEX | GROUP BY 절의 처리를 위한 인덱스 사용 여부 제어 | 인덱스 |
    | JOIN_INDEX,
    NO_JOIN_INDEX | WHERE 절의 처리를 위한 인덱스 사용 여부 제어 | 인덱스 |
    | ORDER_INDEX,
    NO_ORDER_INDEX | ORDER BY 절의 처리를 위한 인덱스 사용 여부 제어 | 인덱스 |
- **MAX_EXECUTION_TIME**
  옵티마이저 힌트 중 **유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트**이다.

      **ms 단위의 시간**을 설정하며, 지정된 시간을 초과하면 해당 쿼리는 실패하게 된다.

- **SET_VAR**

  다양한 형태의 시스템 변수 조정을 할 수 있지만 모든 시스템 변수를 SET_VAR 힌트로 조정할 수는 없다. SET_VAR 힌트는 실행 계획을 바꾸는 목적 뿐만 아니라 **조인 버퍼나 정렬용 버퍼 (소트 버퍼)의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상**시키는 용도로 사용할 수 있다.

- **SEMIJOIN\* & NO_SEMIJOIN**

  세미 조인의 최적화는 여러 가지 세부 전략이 있다. → 9.3.1.9절 ‘세미 조인’ 참조

  SEMIJOIN 힌트를 통해 어떤 세부 전략을 사용할지 제어할 수 있다.

  NO_SEMIJOIN 힌트를 통해 해당 세미 조인 최적화 전략을 사용하지 않게 할 수 있다.

  .\* 세미 조인: 내부적으로 조인을 통해 조회하지만 조건을 만족하는 행이 있는지만 보고, 그 데이터는 가져오지 않는 조인 ex. `EXISTS`

- **SUBQUERY**
  서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 대 사용하는 최적화 방법이다.
  서브쿼리 최적화 힌트는 세미 조인 최적화 힌트와 비슷한 형태로, 서브쿼리에 힌트를 사용하거나 서브쿼리에 블록 이름을 지정해서 외부 쿼리 블록에서 최적화 방법을 명시하면 된다.
  서브쿼리 최적화 전략은 사용할 기회가 그다지 많지 않다.
- **BNL & NO_BNL & HASHJOIN & NO_HASHJOIN**

  MySQL 8.0.19 버전까지는 Block Nested Loop 조인 알고리즘을 사용했지만 MySQL 8.0.18버전부터 도입된 해시 조인 알고리즘이 MySQL 8.0.20 버전부터는 Block Nested Loop 조인까지 대체하도록 개선됐다.

  MySQL 8.0.20버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않는다. 하지만 BNL, N_BNL 힌트는 그 이후 버전에서도 사용 가능하며, **해시 조인을 사용/비사용 하도록 유도**하는 힌트로 용도가 변경됐다. 대신 HASHJOIN과 NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만 유효하며, 그 이후 버전에서는 효력이 없다.

- **JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX**

  STRAIGHT_JOIN 힌트는 FROM절에 사용된 테이블 순서를 조인 순서에 맞게 변경해야 하는 번거로움이 있었다. 또한, 일부에 대해서만 조인 순서를 강제할 수 없었다.

  이러한 단점을 보완하기 위해 옵티마이저 힌트에서는 다음같은 4개의 힌트를 제공한다.

  - JOIN_FIXED_ORDER: STRAIGHT_JOIN 힌트와 동일하게 FROM절의 테이블 순서대로 조인을 실행하게 하는 힌트
  - JOIN_ORDER: FROM절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
  - JOIN_PREFIX: 조인에서 드라이빙 테이블만 강제하는 힌트
  - JOIN_SUFFIX: 조인에서 드리븐 테이블 (가장 마지막에 조인돼야 할 테이블들)만 강제하는 힌트

- **MERGE & NO_MERGE**

  불필요한 자원 소모를 막기 위해 **내부 쿼리를 외부 쿼리와 병합**하는 것이 나을 수도 있고, 때로는 **내부 임시 테이블을 생성**하는 것이 더 나은 선택일 수도 있다. MySQL 옵티마이저가 최적의 방법을 선택하지 못 할 때 이 힌트를 사용할 수 있다.

  ````sql
  "임시 테이블을 사용하지 않고 내부 쿼리를 외부 쿼리와 병합한다"는 말은, 서브쿼리를 따로 실행해서 결과를 저장하지 않고, 실행 계획(Execution Plan) 상에서 외부 쿼리와 함께 최적화해서 동시에 처리한다는 의미예요.
  =============================================
  **# 일반적인 서브쿼리 방식 (임시 테이블 사용)**
  	```
  	SELECT name
  	FROM user
  	WHERE id IN (
  	    SELECT user_id
  	    FROM review
  	    WHERE product_id = 1001
  	);
  	```
  	위 쿼리를 실행할 때 MySQL 등은 기본적으로:

  	서브쿼리 먼저 실행 → review 테이블에서 product_id = 1001인 user_id들을 임시 테이블(메모리나 디스크)에 저장

  	그 다음 외부 쿼리에서 user.id가 그 안에 포함되어 있는지 비교

  	✅ 이렇게 하면, 서브쿼리의 결과가 고정돼서 효율적일 수도 있지만
  	❌ 임시 테이블 생성/비교로 인해 성능 저하 가능
  ===================================================
  **# 반면 "병합"이란?**
  	MySQL 옵티마이저가 이 서브쿼리를 따로 저장하지 않고, 외부 쿼리와 같이 엮어서 처리해버려요. 이걸 "병합(Merge)" 또는 "쿼리 리라이팅(Query Rewriting)"이라고 해요.

  	예를 들어 다음처럼:
  	```
  	-- 원래는 IN 서브쿼리
  	SELECT name
  	FROM user
  	WHERE id IN (
  	    SELECT user_id FROM review WHERE product_id = 1001
  	);
  	```
  	```
  	-- 병합 후 (조인으로 변경됨)
  	SELECT DISTINCT u.name
  	FROM user u
  	JOIN review r ON u.id = r.user_id
  	WHERE r.product_id = 1001;
  	```
  	👉 이 방식은 임시 테이블 없이, 쿼리 전체를 하나의 조인 쿼리로 변환해서 실행해요.

  	💡 왜 병합하냐?
  	- 불필요한 임시 테이블 I/O 줄임
  	- 옵티마이저가 더 나은 조인 순서/인덱스 활용 가능
  	- 결과적으로 성능이 좋아질 수 있음
  ````

- **INDEX_MERGE & NO_INDEX_MERGE**
  MySQL 서버는 가능하다면 테이블당 하나의 인덱스만을 이용해 처리하려고 한다.
  하지만 하나의 인덱스만으로 검색 대상 범위를 충분히 좁힐 수 없다면 MySQL 서버는 여러 인덱스를 통해 검색된 레코드로부터 교집합 또는 합집합만을 구해서 그 결과를 반환한다.
  이처럼 **하나의 테이블**에 대해 **여러 개의 인덱스를 동시에 사용하는 것**을 **인덱스 머지**라고 한다.
  인덱스 머지 실행 계획의 사용 여부를 제어할 때 해당 힌트를 사용한다.
- **NO_ICP**

  **인덱스 컨디션 푸시다운\* 최적화는 사용 가능하다면 항상 성능 향상에 도움이 되므로** MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립한다.

  그런데 ICP로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.

  .\* **Index Condition Push down: 인덱스를 사용할 때, 가능한 `WHERE` 조건을 스토리지 엔진이 직접 처리하도록 푸시해서, 디스크 I/O를 줄이고 속도를 높이는 기법**

- **SKIP_SCAN & NO_SKIP_SCAN**

  인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능이다. 하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능은 오히려 더 떨어진다.

  해당 힌트로 비효율적인 인덱스 스킵 스캔을 선택하는 경우를 제어할 수 있다.

- **INDEX & NO_INDEX**
  예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다.
  인덱스 힌트는 특정 테이블 뒤에 사용했기 때문에 별도로 힌트 내에 테이블명 없이 인덱스 이름만 나열했지만 옵티마이저 힌트에는 테이믈병과 인덱스 이름을 함께 명시해야 한다.
