# § 4.1 MySQL 엔진 아키텍처

MySQL 서버는 MySQL 엔진 + 스토리지 엔진으로 이루어진다.

## MySQL 엔진

- 커넥션 핸들러: 클라이언트 접속, 쿼리 요청 처리
- SQL 인터페이스
- SQL 파서
- SQL 옵티마이저: 쿼리 최적화
- 캐시 & 버퍼

## 스토리지 엔진

실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 역할

MySQL은 Inno DB, MyISAM 등을 지원.

 MySQL 엔진은 `Handler API`를 통해 스토리지 엔진에 쓰기/읽기를 요청

## MySQL 쓰레딩 구조

MySQL 서버는 프로세스 기반이 아니라 쓰레드 기반으로 동작함.

대부분의 쓰레드는 백그라운드 쓰레드.

### Foreground Thread(클라이언트 쓰레드)

- 최소 MySQL 서버에 접속한 클라이언트 수만큼 존재.
- 클라이언트가 요청하는 쿼리 문장을 처리함.
- 클라이언트가 접속을 종료하면 해당 쓰레드는 쓰레드 캐시로 돌아간다. (이미 쓰레드 캐시에 일정 개수 이상의 대기 중 쓰레드가 있으면 캐시에 넣지 않고 삭제)
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴.
- 버퍼나 캐시에 없을 경우 직접 디스크나 인덱스 파일로부터 데이터를 읽어와 작업 처리
- MyISAM의 경우 디스크 쓰기 작업까지 포그라운드 쓰레드가 담당

### Background Thread

- Insert Buffer를 병합하는 쓰레드
- 로그를 디스크에 기록하는 쓰레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 쓰레드 (InnoDB에서는 쓰기 버퍼링 가능)
- 데이터를 버퍼로 읽어 오는 쓰레드
- 잠금이나 데드락을 모니터링 하는 쓰레드 등

### ? 디스크로부터 데이터를 가져와 버퍼에 담는 쓰레드 ?

실시간으로 필요한 데이터를 가져올 때는 포그라운드 스레드, 미리 데이터를 캐싱해 두는 등의 작업은 백그라운드 스레드가 담당

## 메모리 할당 및 사용 구조

### 글로벌 메모리

클라이언트 쓰레드의 수와 무관하게 하나의 메모리 공간만 할당됨.

MySQL 서버 내에 존재하는 많은 쓰레드가 공유해서 사용

1. **테이블 캐시 (Table Cache)**
    - 테이블 핸들을 캐싱하여 **파일 오픈/클로즈 비용을 줄이고 성능을 향상**시키는 역할.
    - MySQL에서 테이블을 열면 파일 디스크립터를 사용하는데, 이를 효율적으로 관리함.
    - `table_open_cache` 변수로 크기 조절 가능.

1. **InnoDB 버퍼 풀 (InnoDB Buffer Pool)**
    - **InnoDB 스토리지 엔진에서 가장 중요한 메모리 영역**.
    - 디스크에서 읽은 데이터 페이지를 캐싱하여 자주 사용되는 데이터를 빠르게 제공.
    - 데이터 페이지뿐만 아니라 인덱스 페이지도 캐싱함.
    - `innodb_buffer_pool_size` 설정으로 크기 조절 가능.

1. **InnoDB 어댑티브 해시 인덱스 (InnoDB Adaptive Hash Index)**
    - 자주 접근하는 데이터 패턴을 학습하여 자동으로 **해시 인덱스를 생성**함.
    - B+ 트리 기반의 인덱스를 보완하여 검색 속도를 향상시키는 역할.
    - `innodb_adaptive_hash_index` 설정을 통해 활성화/비활성화 가능.

1. **InnoDB 리두 로그 버퍼 (InnoDB Redo Log Buffer)**
    - 트랜잭션 수행 시 변경 내용을 **즉시 디스크에 쓰지 않고 먼저 버퍼에 저장**하는 공간.
    - 일정 시간 또는 특정 조건이 충족되면 **리두 로그 파일(redo log file)** 에 기록됨.
    - 크기가 너무 작으면 자주 디스크에 플러시(Flush)해야 하므로 성능 저하 발생 가능.
    - `innodb_log_buffer_size` 변수로 크기 조절 가능.

### 로컬 메모리 (세션 메모리/클라이언트 메모리)

각 클라이언트 쓰레드 별로 독립적으로 할당

1. **정렬 버퍼 (Sort Buffer)**
    - ORDER BY, GROUP BY 같은 **정렬 연산이 필요할 때 사용하는 메모리 공간**.
    - 정렬할 데이터가 많아 정렬 버퍼를 초과하면 **디스크 임시 테이블을 사용**하므로 성능 저하가 발생할 수 있음.
    - `sort_buffer_size` 변수로 크기 조절 가능.

1. **조인 버퍼 (Join Buffer)**
    - 인덱스를 사용하지 않는 조인(특히 **Nested Loop Join**)을 수행할 때 사용하는 메모리.
    - `join_buffer_size` 값이 작으면 조인 연산 시 디스크 접근이 많아져 속도가 느려짐.
    - **인덱스를 활용하면 조인 버퍼를 덜 사용하게 되므로, 인덱스 최적화가 중요**.

1. **바이너리 로그 캐시 (Binary Log Cache)**
    - 바이너리 로그(Binlog)에 기록할 데이터를 임시로 저장하는 버퍼.
    - 트랜잭션이 커밋될 때까지 변경 사항을 로그로 기록하지 않고 캐시에 저장했다가 한 번에 씀.
    - `binlog_cache_size` 로 크기 조절 가능.

1. **네트워크 버퍼 (Network Buffer)**
    - 클라이언트와 MySQL 서버 간 **데이터 전송을 위한 버퍼**.
    - 클라이언트에서 SQL을 전송하거나 서버에서 결과를 보낼 때 사용됨.
    - `net_buffer_length` 와 `max_allowed_packet` 값을 조절하여 성능 튜닝 가능.

# § 4.2 InnoDB 스토리지 엔진 아키텍처

### 프라이머리 키에 의한 클러스터링

- 프라이머리 키 값의 순서대로 디스크에 저장
- 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
- 프라이머리 키를 이용한 레인지 스캔이 빠르다

### 외래 키 지원

- 외래 키는 스토리지 엔진 레벨에서 지원하는 기능임.
- MyISAM 이나 MEMORY 테이블에서는 사용할 수 없음.

## MVCC (Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능.
- 잠금을 사용하지 않는 일관된 읽기 제공
- Read Committed, Repeatable Read에서는 Update 되기 전 데이터를 저장하는 Undo Log에서 값을 읽어 반환.
- 트랜잭션이 길어지면 언두 로그에서 관리해야 하는 데이터가 많아지고, 공간이 커지게 됨.
- 언두 영역은 필요로 하는 트랜잭션이 없어지면 삭제된다.

## 자동 데드락 감지

- 데드락 감지 쓰레드가 주기적으로 잠금 대기 그래프를 검사, 교착 상태의 트랜잭션들 중 하나를 강제 종료
- 언두 로그 레코드가 적은 트랜잭션이 종료된다.

## InnoDB 버퍼 풀

1. 디스크의 데이터 파일이나 인덱스 정보를 캐싱해두는 공간
2. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있도록 하는 버퍼 역할

버퍼 풀은 페이지의 조각으로 쪼개지고, InnoDB 스토리지 엔진은 LRU(+MRU) 리스트, Flush 리스트, Free 리스트로 버퍼 풀의 페이지 조각을 관리한다.

InnoDB 스토리지 엔진이 데이터를 필요로 할 때, 데이터 페이지를 읽어 각 조각에 저장한다.

![image.png](attachment:3988875e-9a90-4af9-ba78-457d4366acd6:image.png)

### LRU 리스트

디스크로부터 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀에 유지하여 디스크 읽기를 최소화 하기 위해 사용

1. 필요한 데이터가 메모리(InnoDB 버퍼 풀)에 있는지 확인
    1. InnoDB 어댑티브 해시 인덱스를 이용해 검색
    2. B-Tree에서 인덱스 검색
2. 있다면 해당 데이터를 MRU 방향으로 이동
3. 없다면 디스크로부터 읽어와 버퍼 풀에 추가
4. 사용되지 않는 데이터는 사용 빈도와 나이(age)를 고려하여 메모리에서 삭제
5. 자주 사용된 데이터는 어댑티브 해시 인덱스에 등록

### Flush 리스트

- 더티페이지(디스크로 write 되지 않은 데이터를 가진 페이지) 목록을 관리.
- 디스크에서 읽어 온 이후 변경이 있다면 플러시 리스트에 등록이 되고, 특정 시점에 디스크에 기록이 되어야 함.
- 데이터가 변경되면
    - Redo 로그(디스크)에 변경 내용 기록
    - 메모리(InnoDB 버퍼 풀)의 데이터 페이지 업데이트 + 데이터 페이지를 플러시 리스트에 추가
    - 체크 포인트 마다 플러시 리스트에 더티 페이지를 디스크에 저장

### Double Write Buffer

- InnoDB  스토리지 엔진은 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만을 기록.
- 더티  페이지의 내용이 디스크에 쓰이는 도중 장애가 발생하면, 페이지의 일부만 기록될 수 있다. (Partial-page/Torn-page)
- 변경된 페이지를 Double Write Buffer 라는 별도 버퍼 영역에 저장, 테이블 파일(디스크)로 복사
- Double Write Buffer에 저장된 데이터를 실제 테이블 파일(디스크)에 기록
- Partial-page 발생 시 Double Write Buffer 의 내용을 불러와 다시 디스크에 기록 할 수 있음.
- 정상적으로 저장되었으면 Double Write Buffer 에서 제거
- 데이터 저장 성능은 낮아지지만(디스크에 두 번 저장), 안정성이 높음.
    
    
    | 기능 | **리두 로그 (Redo Log)** | **Double Write Buffer** |
    | --- | --- | --- |
    | **대비하는 장애** | 사용자의 쿼리 실행 도중 MySQL이 비정상 종료될 경우 | 데이터 페이지가 디스크에 기록될 때 부분적으로 저장되거나 손상될 경우 (Torn Page) |
    | **보관하는 정보** | **변경된 데이터의 변경 내역** (변경 기록) | **완전한 데이터 페이지(16KB) 자체를 미리 저장** |
    | **장애 발생 시 복구 방법** | 리두 로그를 다시 실행하여 변경 사항을 재적용 | Double Write Buffer에 저장된 정상적인 페이지를 복사하여 복구 |
    | **저장 위치** | `ib_logfile0`, `ib_logfile1` (디스크의 로그 파일) | InnoDB 시스템 테이블 스페이스 내부 |
    | **언제 디스크에 저장?** | 트랜잭션이 커밋될 때 | 특정 주기마다 (체크포인트와 연관) |

## ※ 격리 수준, MVCC 보충

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/e72c2297-21d1-4c4e-a7db-7ec21cd1c8da/image.png)

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것 

## SERIALIZABLE

- 가장 엄격한 격리 수준.
- 트랜잭션을 순차적으로 진행시킨다.
- 여러 트랜잭션이 동일한 레코드에 접근할 수 없으므로 어떠한 데이터 부정합 문제도 일으키지 않는다.
- 동시 처리 성능이 매우 떨어짐
- SELECT FOR SHARE/UPDATE 아닌 순수 SELECT는 아무런 레코드 잠금 없이 실행됨(Non-locking consistent read) 지만 SERIALIZABLE 격리 수준에서는 순수 SELECT 작업에서도 대상 레코드의 락을 Shared Lock으로 건다.
- 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용하지 말아야 한다.

## REPEATABLE READ

- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리 수준
- 팬텀 리드(Phantom Read) 발생 가능
- 일반적인 RDBMS는 변경 전의 레코드를 Undo 공간에 백업 해두는데, 변경 전/후 데이터가 모두 존재하므로 동일한 레코드에 대해 여러 버전의 데이터가 존재한다고 하여 이것을 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부른다.
- 백업 레코드에는 어느 트랜잭션에 의해 백업 되었는지 트랜잭션 번호를 함께 저장한다.
→ 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된 데이터만 볼 수 있음

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/1af87e14-10b7-463c-af49-8c0f72034a14/image.png)

사용자 B가 select, B의 트랜잭션이 끝나지 않은 상태에서 A가 update, commit 했으나

B의 트랜잭션이 먼저 시작했으므로 B는 자신의 트랜잭션 ID보다 작은 데이터만 볼 수 있음.

Undo 영역에 백업된 모든 레코드는 해당 데이터가 불필요하다고 판단하는 시점에 백그라운드 쓰레드를 통해 삭제

REPEATABLE READ는 MVCC를 통해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/5c9c27e6-a24e-407e-9602-48ac8fc3a548/image.png)

→ Phantom Read (MySQL을 제외한 RDBMS)

사용자 B의 트랜잭션에서 select for update 구문으로 발생한 쓰기 잠금은 id=50인 레코드에만 걸리게 되고,

A의 insert 요청은 정상적으로 수행된다.

REPEATABLE READ는 레코드의 추가까지는 막지 않기 때문

https://mangkyu.tistory.com/299

but MySQL은 특수한 gap lock 이 존재하기 때문에 id=50인 레코드만 있는 상태에서도 id ≥ 50에 대해 락이 걸리게 되어 A의 트랜잭션 내 insert 명령은 수행되지 않는다.

## READ COMMITTED

- 커밋된 데이터만 조회할 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/03b95408-ec6c-447c-bd85-03f4d327addb/image.png)

- Phantom Read, Non-Repeatable Read 문제 발생 가능

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/c2d0c55a-72ec-413e-9bb1-beda32e48bab/image.png)

Non-Repeatable Read는 일반적인 경우에는 크게 문제가 되지 않지만, 
하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 생길 수 있다. 

예를 들어 어떤 트랜잭션에서는 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상황이라고 하자. 그러면 READ COMMITTED에서는 같은 트랜잭션일지라도 조회할 때마다 입금된 내역이 달라지므로 문제가 생길 수 있다.

## READ UNCOMMITED

- 커밋하지 않은 데이터에도 접근할 수 있다.
- 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 됨

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61ae2243-abf3-4add-9287-918dcbd29f45/7cf901ce-5e1e-44b3-b65f-5a20fbdd438d/image.png)

Dirty Read: 어떤 트랜잭션의 작업이 완료되지 않았는데도 다른 트랜잭션에서 데이터를 볼 수 있는 부정합 문제

- RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많다