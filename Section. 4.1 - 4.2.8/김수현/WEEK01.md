# 4.1 MySQL 엔진

- MySQL 서버 = MySQL 엔진(1개) + 스토리지 엔진(N개)
    - MySQL 엔진 : SQL 문장 분석, 최적화 ⇒ DBMS의 두뇌 역할
    - 스토리지 엔진 : 디스크 스토리지에 데이터 저장 및 조회
    - MySQL 엔진  — (핸들러 AP)I —> 스토리지엔진

- MySQL 서버 : 스레드 기반 작동 (Not 프로세스 기반)


    | 구분 | 프로세스 (Process) | 스레드 (Thread) |
    | --- | --- | --- |
    | 정의 | OS로부터 독립적으로 실행되는 작업 단위 | 프로세스 내에서 실행되는 흐름 단위 (Lightweight Process) |
    | 메모리 공유 | 독립적인 메모리 공간 할당 (Code, Data, Heap, Stack) | Code, Data, Heap을 공유하고 Stack만 별도 할당 |
    | 실행 속도 | 상대적으로 느림 (Context Switching 비용 발생) | 상대적으로 빠름 (Stack만 전환하면 되므로 비용 적음) |
    | 생성 비용 | 프로세스 생성 비용 높음 (OS가 별도 리소스 할당) | 프로세스 내에서 생성되므로 비용이 낮음 |
    | 통신 방식 | 프로세스 간 통신 (IPC: 파이프, 메시지 큐, 공유 메모리 등) | 동일 프로세스 내에서 공유 메모리 사용 가능 |
    | 독립성 | 다른 프로세스와 독립적이며 종료해도 영향 없음 | 같은 프로세스 내 다른 스레드에 영향을 미칠 수 있음 |
    | 예제 | 웹 브라우저, 데이터베이스 서버 등 | 웹 브라우저의 여러 탭, MySQL 스레드 기반 처리 |
    
    | 구분 | 정의 | 비고 (특징 및 장단점) |
    | --- | --- | --- |
    | **프로세스 기반** | 프로세스가 독립적인 메모리 공간과 자원을 갖고, 자체 주소 공간에서 실행되는 형태 | - 독립적인 실행 환경 제공 → 하나의 프로세스 종료가 다른 프로세스에 영향 없음  - 프로세스 간 통신(IPC) 필요 → 오버헤드 발생 가능 |
    | **스레드 기반** | 하나의 프로세스 내에서 여러 실행 단위를 나누어 병렬 처리하는 형태 | - 같은 주소 공간을 공유하여 자원 사용이 효율적  - 동기화 문제 발생 가능 → Mutex, Semaphore 등의 동기화 기법 필요 |
    - 프그라운드 스레드(클라이언트 스레드)
        - 역할 : 클라이언트 요청하는 쿼리 문장 처리 → 데이터가 데이터 버퍼 혹은 캐시 존재할 경우 그로부터 가져오며 그 밖의 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터 가져온다.
        - 비고 : 스레드 캐시에 적재되며 스레드 캐시에 적재할 수 있는 최대 스레드 갯수(thread_cache_size) 이상 대기 중 스레드 존재 시 스레드 종료
    - 백그라운드 스레드
        - 역할 : 버퍼로부터 디스크에 데이터를 기록 → 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업이 핵심이다.

- MySQL 메모리 공간 : 글로벌 메모리 + 로컬 메모리
    - 글로벌 메모리 : 명칭과 같이 MySQL 서버 내의 많은 스레드가 공유해서 사용하는 공간으로써 MySQL 서버마다 단 1개 존재 ex) 테이블 캐시, InnoDB 버퍼 풀 / 어댑티브 해시 인덱스 / 리드 로그 버퍼
    - 로컬 메모리 : MySQL 서버 내의 스레드마다 독립적으로 할당되는 메모리 영역 ex) 커넥션 버퍼, 정렬(소트) 버퍼

- MySQL 플러그인 모델
    - 역할 : 확장성을 높이고 기능을 추가할 수 있도록 하는 구조로 사용자가 필요에 따라 특정 기능을 추가하거나 수정할 수 있습니다. (MySQL 서버와 통신, 플러그인 간의 통신 불가능)

- MySQL 핸들러
    - 역할 : MySQL 엔진이 스토리지 엔진 조정하기 위해 사용 ⇒ MySQL 엔진이 스토리지 엔진에게 데이터 조회, 저장 명령 시에 핸들러를 통해서 수행

- MySQL 컴포넌트
    - 역할 : MySQL 서버의 다양한 기능을 모듈화하여 확장성을 제공하는 구조 ⇒  기존의 플러그인과 유사하지만 더 강력한 확장 기능을 제공하며 플러그인 간의 통신이 가능

- MySQL 쿼리 실행 구조 : 클라이언트 — (SQL요청) —> MySQL 엔진(쿼리 파서 —> 전처리기 —> 옵티마이저 —> 쿼리 실행기) —> 스토리지 엔진
    - 쿼리 파서 : SQL → 토큰(MySQL 인식하는 최소 단위 어휘 혹은 기호)
    - 전처리기 : 토큰(트리 형태) 구조적 문제 check
    - 옵티마이저 :
        - 쿼리 변환
        - 비용 최적화 : 가장 저렴한 비용으로 가장 빠르게)
        - 실행 계획 수립

- MySQL 쿼리 캐시
    - 역할 : SQL 실행 결과를 메모리에 캐시 → 동일 쿼리 실행 시 테이블 조회 과정 생략하고 바로 결과 반환
    - 문제점 : 데이터 변환 시 관련 테이블의 캐시 전부 삭제 → 동시 처리 성능 저하
    - 현 상황 : MySQL 8.0에서 해당 기능, 관련 시스템 변수 전부 삭제

- MySQL 스레드 풀
    - 역할 : 요청 처리하는 스레드 갯수를 제한해 제한된 갯수의 스레드 처리에만 집중 → 서버 자원 소모 줄임
    - 이상 : 스레드 풀 설치 시 비약적인 성능 개선
    - 현실  : 눈에 띄는 성능 향상은 기대하기 어렵다. → CPU 처리 시간 제대로 확보하지 못할 시에 스케줄링 과정으로 인해 쿼리 처리가 더 느려지는 사례 존재


- MySQL 트랜잭션 지원 메타데이터(데이터 딕셔너리)
    - 정의 : 테이블 구조, 스토이드 프로그램 등 정보
    - MySQL 8.0 이전
        - 관리 방식 : 테이블 구조 FRM 파일, 일부 스토이드 프로그램 또한 파일(.TRN, .TRG, .PAR …) 기반 관리
        - 문제점 : 메타데이터 생성 및 변경이 트랜잭션 지원 X → 동시성 문제 발생(데이터베이스나 테이블이 깨졌다)
    - MySQL 8.0 이후
        - 관리 방식 : 테이블 구조, 스토이드 프로그램 정보를 InnoDB의 테이블에 저장 → 동시성 문제 해결(스키마 변경 중 MySQL 서버 비정상적 종료된 경우에 완전한 성공, 완전한 실패로 처리)

# 4.2 InnoDB 스토리지 엔진 아키텍처

- MVCC(Multi Version Concurrency Control)
    - 정의 : 잠금 사용하지 않은 일반적인 읽기
    - InnoDB 버퍼풀
        - 데이터 페이지(행)를 메모리에 저장
        - 덥데이트된 페이지를 Dirty Page로 유지
        - 일정 시간 경과 후 디스크에 기록(Flush)
    - Undo 로그
        - 변경 전 데이터 저장해 MVCC 및 롤백 지원
        - 트랜잭션 완료 시 정리(Purge)
    - Redo 로그
        - 변경된 내용을 반영 전 기록해 장애 시 복구
    - Update 시 작동 방식
        1. Update 요청
        2. 새로운 값으로 업데이트 전 기존의 값(튜플 단위)만을 Undo 로그에 복사
        3. InnoDB  버퍼풀에 새로운 값으로 업데이트
        4. 디스크 데이터 파일의 경우 시점에 따라 다르다
    - 격리 수준에 따른 Commit 혹은 Rollback 되지 않은 상태에서 다른 사용자 변경된 내용 조회
        - READ_UNCOMMITED : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터 읽어 반화(커밋 여부 상관없이 버퍼 풀에서 데이터 조회)
        - READ_COMMITED, REPEATABLE_READ, SERIALIZABLE : 커밋되지 않았기에 InnoDB, 데이터 파일 내용 대신 변경 이전의 내용 보관하는 Undo 영역 데이터 반환
    - Commit 실행 : InnoDB 현 상태를 영구적인 데이터로 만듬
    - Rollback 실행 : Undo 로그의 백업 데이터 InnoDB 버퍼 풀로 복구하고 Undo 영역의 데이터 삭제

- 자동 데드락 감지
    - 역할 : 주기적으로 잠금 대기 그래프(Wait -For List) 언두 로그 레코드가 가장 적게 가진 트랜잭션 종료(언두 로그 레코드가 적다 = 롤백 시 처리량 적다) → 내부적으로 잠금이 교착 상태 빠지는 것을 방지

- 자동화된 장애 복구
    - 역할 : 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구하지 못하거나 MySQL 서버 내부 문제(거의 발생X)으로 인해 장동으로 복구 못하는 경우 해결하기 위해 MySQL 서버 시작 시 항상 자동 복구 실행

- InnoDB 버퍼 풀
    - 역할 : 디스크 데이터 파일 혹은 인덱스 정보 캐시 / 쓰기 지연으로  batch 처리 → 랜덤 디스크 작업 횟수 줄임
    - 크기 설정
        - MySQL 5.7 이전 : InnoDB의 버퍼 풀 크기를 동적으로 조절하지 못한다 → innodb_buffer_pool_size 설정 변경하려면 MySQL 서버 재시작해야한다.
        - MySQL 5.7 이후 : InnoDB의 버퍼 풀 크기를 동적으로 조절가능하다. → SET GLOBAL innodb_buffer_pool_size = <크기>; 명령을 사용해 MySQL 서버 재시작하지 않고 버퍼 풀 크기 변경 가능
        - InnoDB 버퍼 풀 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만 버퍼 풀 크기 줄이는 작업은 서비스 영향도 매우 크다. → 줄이는 작업은 최대한 피하자
    - 구조 : 페이지 크기의 조각으로 쪼개서 InnoDB 스토리지 엔진이 데이터 필요 시 해당 페이지 읽어 각 조각에 저장
    - 관리
        1. LRU(Least Recently Used) 리스트 : 버퍼 풀의 메모리에 디스크로 읽은 페이지 유지해 디스크 읽기 최소화
            1. Old 서브리스트(LRU) : 거의 사용되지 않는 데이터 페이지 적재, LRU 끝으로 밀릴 시 InnoDB 버퍼 풀에서 삭제
            2. New 서브리스트(MRU) : 데이터 페이지 자주 사용 시 해당 영역에 계속 살아남음
        2. 플러시( Flush) 리스트 : 디스크로 동기화 되지 않은 페이지(더티 페이지) 변경 시점 기준의 페이지 목록 관리
        3. 프리(Free) 리스트 : 데이터로 채워지지 않은 페이지 목록, 새로운 디스크 데이터 페이지 읽을 시에 사용
    - 버퍼 풀과 리두 로그
    - 플러시(Flush)
        - 플러시 리스트(Flush_list) 플러시
            - 역할 : 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화
            - 시스템 변수
                1. innodb_page_cleaners : 클리너 스레드 갯수 조정
                2. innodb_buffer_pool_instance : InnoDB 버퍼 풀을 여러 개의 인스턴스로 분할하여 동시성을 높이고 경합(Contention)을 줄이는 역할 → 크기에 따라 여러 개의 인스턴스로 분할 가능, innodb_page_cleaners의 설정값도 동일한 값으로 가는 것이 이상적(1개의 클리너 스레드가 하나의 버퍼 풀 인스턴스 처리)
                3. innodb_max_dirty_pages_pct : 더티 페이지 비율을 조정(가능하면 기본값 유지)
                4. innodb_max_dirty_pages_pct _lwm : 일정 수준 이상 더티 페이지 발생 시 조금씩 더티 페이지를 디스크에 기록
        - LRU 리스트(LRU_list) 플러시
            - 역할 : LRU 리스트에서 사용 빈도 낮은 데이터 페이지 제거해 새로운 페이지 읽을 공간 만드는 역할
    - 상태 백업 및 복구
        - 워밍업(Warming Up) : 디스크 데이터가 버퍼 풀에 적재된 상태 → 버퍼 풀의 워밍업이 잘된 상태 = 빠른 쿼리 속도 처리
            - MySQL 5.6 이전 : MySQL 서버 재시작 시 강제 워밍업을 위해 테이블과 인덱스 풀 스캔 실행
            - MySQL 5.6 이후 : MySQL 셧다운 전에 innodb_buffer_pool_dump_now로 현 InnoDB 버퍼 풀 상태 백업, 재시작 시 백업된 버퍼 풀 복구
    - 적재 내용 확인
        - MySQL 5.6 ~ MySQL 8.0 이전 : MySQL 서버의 information_schema 데이터베이스의 innodb_buffer_page 테이블 이용해 테이블의 페이지 적재 확인 가능 → 부하가 큰 이유로 서비스 쿼리 성능 문제
        - MySQL 8.0 이후 : information_schema 데이터베이스의 innodb_cached_indexes로 테이블 인덱스 별 데이터 페이지 얼마나 적재되어 있는지 확인

- Double Write Buffer
    - 개요 : InnoDB 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러 시 일부만 기록되는 문제 발생 시 해당 페이지 내용 복구 불가능 = 파셜 페이지(Partial-page) 혹은 톤 페이지(Torn-page)
    - 역할 : InnoDB 스토리지 엔진에서 데이터 페이지를 디스크에 안전하게 기록하기 위한 보호 메커니즘으로 파셜 페이지를 방지하기 위해 데이터를 두 번 기록하는 방식
    - 동작 방식
        1. InnoDB가 데이터 페이지 변경 시 먼저 Double Write Buffer에 데이터 기록
        2. Double Write Buffer에 기록 완료 시 실제 테이블스페이스(데어터 파일)에 데이터 저장
        3. 체크포인트 발생 시 Double Write Buffer는 삭제되고 새로운 데이터 기록할 준비
        4. 만약 비정상 종료 등과 같은 문제 발생 시 Double Write Buffer에 있는 데이터를 이용하여 손상된 페이지를 복구