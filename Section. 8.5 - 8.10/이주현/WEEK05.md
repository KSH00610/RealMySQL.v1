# § 8.5 전문 검색 인덱스

MySQL의 B-Tree 인덱스는 실제 칼럼의 값이 1MB이더라도, 1,000바이트(MyISAM) 또는 3,072바이트(InnoDB)까지만 잘라서 인덱스 키로 사용한다.  
따라서 문서의 내용 전체를 인덱스화 해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색에는 B-Tree 인덱스를 사용할 수 없다.

## § 8.5.1 인덱스 알고리즘

전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 키워드로 인덱스를 구축한다.

### § 8.5.1.1 어근 분석 알고리즘

1. 불용어(Stop Word) 처리
2. 어근 분석(Stemming)

위 두 가지 과정을 거쳐서 색인 작업이 수행된다.

### § 8.5.1.2 n-gram 알고리즘

본문을 무조건 몇 글자씩 잘라서 인덱싱 하는 방법이다.  
일반적으로는 2글자 단위로 쪼개서 인덱싱하는 2-gram(Bi-gram) 방식이 많이 사용된다.

## § 8.5.2 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 다음 두 가지 조건을 갖춰야 한다.

1. 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...)을 사용
2. 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

```sql
CREATE TABLE tb_test (
    doc_id INT,
    doc_body TEXT,
    PRIMARY KEY (doc_id),
    FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
) ENGINE=InnoDB
```

<br>

```sql
// 풀 테이블 스캔으로 처리됨
SELECT * FROM tb_test WHERE doc_body LIKE '%애플%';
```

<br>

```sql
// 전문 검색으로 처리됨
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('애플' IN BOOLEAN MODE)
```

# § 8.6 함수 기반 인덱스

칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때가 있다.

1. 가상 칼럼을 이용한 인덱스
2. 함수를 이용한 인덱스

인덱싱 할 값을 계산하는 과정에 차이만 있을 뿐, 인덱스의 내부 구조 및 유지관리 방법은 B-Tree 인덱스와 동일하다.

## § 8.6.1 가상 칼럼을 이용한 인덱스

```sql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id)
);
```

MySQL 8.0 부터 가상 칼럼을 추가하고 그 가상 칼럼에 인덱스를 생성할 수 있게 되었다.

```sql
ALTER TABLE user
    ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    ADD INDEX ix_fullname (full_name);
```

가상칼럼이 VIRTUAL / STORED 어떤 옵션으로 생성됐든 관계 없이 인덱스 생성 가능

<br>

## § 8.6.2 함수를 이용한 인덱스

```sql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
);
```

함수 기반 인덱스를 사용하려면  
함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식이 정확히 같아야 한다.  
<br>

# § 8.7 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다.  
하지만 멀티 밸류(Multi-Value) 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스이다.

신용 정보 점수를 배열로 JSON 타입 칼럼에 저장하는 테이블 예시를 보자.

```sql
CREATE TABLE user (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    credit_info JSON,
    INDEX mx_creditscores ( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )
);

INSERT INTO user VALUES(1, 'MATT', 'LEE', '{"credit_scores":[30, 354, 351]}');
```

멀티 밸류 인덱스를 활용하기 위해서는 반드시 다음 함수들을 이용해서 검색해야 한다.

1. MEMBER OF()
2. JSON_CONTAINS()
3. JSON_OVERLAPS()

```sql
SELECT \* FROM user
WHERE 360 MEMBER OF (credit_info->'$.credit_scores');

+---------+------------+-----------+----------------------------------+
| user_id | first_name | last_name | credit_info                      |
+---------+------------+-----------+----------------------------------+
| 1       | Matt       | Lee       | {"credit_scores": [360,353,351]} |
+---------+------------+-----------+----------------------------------+

EXPLAIN SELECT \* FROM user
WHERE 360 MEMBER OF (credit_info->'$.credit_scores');

+----+-------------+-------+------+----------------+---------+-------+---------------+
| id | select_type | table | type | key            | key_len | ref   | Extra         |
+----+-------------+-------+------+----------------+---------+-------+---------------+
| 1  | SIMPLE      | user  | ref  | mx_creditscore | 9       | const | Using where   |
+----+-------------+-------+------+----------------+---------+-------+---------------+
```

<br>

# § 8.8 클러스터링 인덱스

클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용된다.  
MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장. 주로 비슷한 값들을 동시에 조회하는 경우가 많기 때문

## § 8.8.1 클러스터링 인덱스

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.  
프라이머리 키 값에 의해 레코드의 저장 위치가 적용된다.  
-> 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌기 때문에 신중히 프라이머리 키를 결정해야 한다.

![클러스터링 테이블(인덱스) 구조](/Section.%208.5%20-%208.10/이주현/images/8.25.png)  
일반 B-Tree와 비슷하지만, 세컨더리 인덱스를 위한 B-Tree 리프노드와 달리  
리프 노드에 레코드의 모든 칼럼이 같이 저장되어 있다.  
<br>

---

<br>

```sql
UPDATE tb_test SET emp_no=100002 WHERE emp_no=100007;
```

<br>

---

<br>

![업데이트 문장이 실행된 이후의 데이터 구조](/Section.%208.5%20-%208.10/이주현/images/8.26.png)

그림 8.25에서 emp_no=100007 인 레코드는 3번 페이지에 저장되어 있었으나,  
UPDATE 이후 emp_no 가 100002로 변경되면서 2번 페이지로 이동했다.

실제로 프라이머리 키의 값이 변경되는 경우는 거의 없겠으나, 클러스터링 테이블에서 프라이머리 키 값의 중요성을 강조하기 위해 살펴보았다.

<br>

---

<br>

프라이머리 키가 없는 경우에는 InnoDB 스토리지 엔진이 다음 우선 순위대로 프라이머리 키를 대체할 칼럼을 선택한다.

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

3번으로 인해 자동으로 추가된 일련번호 칼럼은 사용자에게 노출되지 않으며, 쿼리에 명시적으로 사용할 수 없다.  
즉 아무 의미 없는 숫자 값으로 클러스터링 되는 것이며, 아무 혜택을 주지 않는다.

<br>

## § 8.8.2 세컨더리 인덱스에 미치는 영향

### MyISAM

세컨더리 인덱스에 ROWID(레코드가 저장된 디스크 상 물리 위치)를 저장  
조회:
`인덱스 -> 데이터 파일`

### InnoDB

테이블이 클러스터링 되어 있다.  
세컨더리 인덱스는 데이터 레코드의 물리 주소가 아닌 프라이머리 키 값을 저장한다.  
조회:
`세컨더리 인덱스 -> 프라이머리 키 인덱스 -> 데이터 파일`

---

### 세컨더리 인덱스에서 프라이머리 키 값을 저장하는 이유

#### 문제 상황

InnoDB는 테이블 데이터를 프라이머리 키 순서에 맞춰 저장하는 클러스터링 구조를 사용한다.

테이블의 프라이머리 키가 변경되면, 레코드의 물리적 저장 위치가 변할 수 있다.

만약 세컨더리 인덱스가 레코드의 물리 주소(ROWID) 를 저장하고 있다면,
레코드 위치가 변할 때마다 세컨더리 인덱스의 값도 함께 수정해야 한다.

이는 데이터 변경 시 매우 큰 오버헤드를 초래할 수 있다.

#### 예시

```
테이블: employees

프라이머리 키: emp_no

세컨더리 인덱스: ix_firstname (first_name)
```

- `세컨더리 인덱스에 물리 주소를 저장하는 경우 (MyISAM 방식)`

  세컨더리 인덱스 항목 저장된 값  
   Matt 0xAB12CD34 (물리적 주소)  
   "Matt"를 찾으면 0xAB12CD34 위치로 바로 이동하여 레코드를 읽는다.

  그러나 emp_no 값이 변경되어 레코드 위치가 바뀌면, 세컨더리 인덱스에 저장된 주소(0xAB12CD34)를 찾아 수정해야 한다.

* `세컨더리 인덱스에 프라이머리 키를 저장하는 경우 (InnoDB 방식)`

  세컨더리 인덱스 항목 저장된 값  
   Matt 1002 (프라이머리 키 값)  
   "Matt"를 찾으면 emp_no=1002를 얻는다.

  emp_no=1002를 프라이머리 키 인덱스를 통해 찾아 실제 레코드를 읽는다.

  emp_no 값이 변하지 않는 한, 데이터 저장 위치가 바뀌더라도 세컨더리 인덱스를 수정할 필요가 없다.

<br>

## § 8.8.3 클러스터링 인덱스의 장점과 단점

### 장점

1. 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름(특히 프라이머리 키를 범위 검색하는 경우)
2. 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)

### 단점

1. 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
2. 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한 번 검색해야 하므로 처리 성능이 느림
3. INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
4. 프라이머리 키를변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

일반적으로 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)  
에서는 쓰기와 읽기비율이 2:8 ~ 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이 매우 중요하다.

## § 8.8.4 클러스터링 테이블 사용 시 주의 사항

### § 8.8.4.1 클러스터링 인덱스 키의 크기

클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함하기 때문에  
프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.

일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면..  
InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 한다.

### § 8.8.4.2 프라이머리 키는 AUTO_INCREMENT 보다는 업무적인 칼럼으로 생성

InnoDB에서 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 물리적인 위치가 결정된다.  
프라이머리 키로 검색하는 경우(특히 범위로 많은 레코드를 검색하는 경우) 매우 빠르게 처리된다.  
설령 그 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.

### § 8.8.4.3 프라이머리 키는 반드시 명시할 것

프라이머리 키를 정의하지 않으면 내부적으로 일련번호 칼럼을 추가한다.  
이 칼럼은 사용자가 전혀 접근 할 수 없다.  
그렇다면 사용자가 사용할 수 있는 값을 프라이머리 키로 설정하는것이 좋을 것이다.

### § 8.8.4.4 AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우

여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우  
세컨더리 인덱스가 필요 없다면 그대로 사용해도 좋지만,  
세컨더리 인덱스도 필요하고 프라이머리 키의 키기도 길다면 AUTO_INCREMENT 칼럼을 추가하고 프라이머리 키로 설정하라.

이렇게 추가된 AUTO_INCREMENT 프라이머리 키를 인조 식별자(Surrogate key) 라고 한다.

<br>

# § 8.9 유니크 인덱스

유니크 인덱스는 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다.
테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미한다.

MySQL에서는 인덱스 생성 시 UNIQUE 제약만 설정하면 된다.

### NULL 허용 여부

- 유니크 인덱스에 NULL이 저장될 수 있다.

- 그러나 NULL이 특정 값이 아니므로 2개 이상 저장 가능하다.

### MySQL의 프라이머리 키

- 기본적으로 NULL을 허용하지 않는 유니크 제약이 자동으로 부여된다.

### MyISAM, MEMORY 테이블과 InnoDB 테이블 간의 차이:

MyISAM, MEMORY: 프라이머리 키에 NULL 허용 안 함.  
InnoDB: 프라이머리 키는 클러스터링 키 역할을 하므로 구조적으로 다름.

<br>

## § 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

유니크 인덱스와 유니크하지 않은 일반 세컨더리 인덱스는
구조상 차이는 없다.

하지만 성능 관점에서 읽기와 쓰기 시 약간의 차이가 발생할 수 있다.

### § 8.9.1.1 인덱스 읽기

일반적인 오해: 유니크 인덱스가 읽기가 더 빠르다.

실제로는 차이가 없다.

#### 이유

인덱스를 탐색하는 과정은 유니크 인덱스나 일반 인덱스 모두 동일하다.

레코드를 찾는 과정(트리 탐색)은 같고,

유니크 인덱스라고 해서 레코드를 읽는 속도가 특별히 빠르지는 않다.

#### 추가 설명

세컨더리 인덱스는 레코드를 한 건 더 읽어야 하는 경우가 있을 수 있다.

유니크 인덱스는 조건을 만족하는 첫 번째 레코드를 찾으면 추가 탐색 없이 바로 멈출 수 있다.

따라서 미세한 수준에서는 유니크 인덱스가 더 빠를 수 있다.

하지만 이 차이는 실질적으로 0.1초 단위로 측정할 수 있는 수준이 아니라,
"2건 읽을 때 0.2초, 1건 읽을 때 0.1초"처럼 미세한 차이에 불과하다.

<br>

## § 8.9.2 유니크 인덱스 사용 시 주의사항

### 필요할 때만 유니크 인덱스를 생성할 것

- 유니크 인덱스는 **필요한 경우에만** 생성하는 것이 원칙이다.
- 성능이 더 좋아질 것이라고 생각하여 **불필요하게 유니크 인덱스를 생성하는 것은 좋지 않다**.

<br>

### 중복 인덱스 생성 주의

- 하나의 테이블에 대해 같은 칼럼에 대해

  - 유니크 인덱스
  - 일반 인덱스
    를 **각각 별도로 생성하는 경우가 종종 있다**.

- 하지만 MySQL에서는 유니크 인덱스가 일반 인덱스와 같은 역할을 수행할 수 있다.
- 즉, 유니크 인덱스가 이미 존재한다면 **일반 인덱스를 추가로 만들 필요가 없다**.

<br>

### 예시

아래는 잘못된 인덱스 생성 예시이다.

```sql
CREATE TABLE tb_unique (
    id INTEGER NOT NULL,
    nick_name VARCHAR(100),
    PRIMARY KEY (id),
    UNIQUE INDEX ux_nickname (nick_name),
    INDEX ix_nickname (nick_name)
);
```

- `nick_name` 칼럼에 대해 **유니크 인덱스(ux_nickname)** 와 **일반 인덱스(ix_nickname)** 를 중복으로 생성했다.
- 이는 불필요하다. `ux_nickname` 유니크 인덱스만 있어도 일반 인덱스 역할을 함께 수행할 수 있기 때문이다.

<br>

### 정리

| 상황                  | 설명                                                          |
| :-------------------- | :------------------------------------------------------------ |
| 유니크 인덱스 존재    | 데이터 유일성 보장 + 인덱스 기능 모두 제공                    |
| 일반 인덱스 추가 생성 | 불필요. 같은 역할을 중복 수행하므로 공간 낭비, 관리 부담 증가 |

**따라서**

- 유니크 인덱스가 있는 칼럼에 대해 일반 인덱스를 별도로 만들지 않는다.
- 인덱스 구조를 심플하게 유지한다.

<br>

# § 8.10 외래키

## 개요

MySQL에서 외래키는 **InnoDB 스토리지 엔진**에서만 생성할 수 있다.  
외래키 제약이 설정되면 다음이 자동으로 이루어진다.

- 연결되는 테이블의 칼럼에 인덱스가 자동 생성된다.
- 외래키가 제거되지 않은 상태에서는 자동 생성된 인덱스를 삭제할 수 없다.

<br>

## InnoDB 외래키 관리 특징

InnoDB의 외래키 관리에는 두 가지 주요 특징이 있다.

1. **테이블이 변경(쓰기 잠금)되는 경우에만 잠금 경합이 발생한다.**
2. **외래키가 설정된 칼럼의 변경은 추가적인 잠금 경합 대기를 발생시키지 않는다.**

<br>

## 예시

### 테이블 생성

```sql
CREATE TABLE tb_parent (
    id INT NOT NULL,
    fd VARCHAR(100) NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB;

CREATE TABLE tb_child (
    id INT NOT NULL,
    pid INT DEFAULT NULL, -- parent.id 칼럼 참조
    fd VARCHAR(100) DEFAULT NULL,
    PRIMARY KEY (id),
    KEY ix_parentid (pid),
    CONSTRAINT child_ibfk_1 FOREIGN KEY (pid) REFERENCES tb_parent (id) ON DELETE CASCADE
) ENGINE=InnoDB;
```

### 데이터 삽입

```sql
INSERT INTO tb_parent VALUES (1, 'parent-1'), (2, 'parent-2');
INSERT INTO tb_child VALUES (100, 1, 'child-100');
```

<br>

# § 8.10.1 자식 테이블의 변경이 대기하는 경우

### 시나리오

| 작업 번호 | 커넥션1                                         | 커넥션2                                 |
| :-------- | :---------------------------------------------- | :-------------------------------------- |
| 1         | BEGIN                                           |                                         |
| 2         | UPDATE tb_parent SET fd='changed-2' WHERE id=2; |                                         |
| 3         |                                                 | BEGIN                                   |
| 4         |                                                 | UPDATE tb_child SET pid=2 WHERE id=100; |
| 5         | ROLLBACK                                        |                                         |
| 6         |                                                 | Query OK                                |

### 설명

- 커넥션1이 `tb_parent` 테이블의 id=2 레코드를 **수정하려고 잠금**을 잡는다.
- 이때 커넥션2가 `tb_child` 테이블에서 pid=2로 수정하는 UPDATE를 시도한다.
- 커넥션2는 커넥션1이 롤백하거나 커밋하기 전까지 **잠금 대기**한다.

> 자식 테이블이 부모 키를 참조하는 외래키가 설정된 경우,  
> 부모 테이블에 쓰기 잠금이 걸리면 자식 테이블의 쓰기 작업은 잠금이 풀릴 때까지 대기한다.

<br>

# § 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

### 시나리오

| 작업 번호 | 커넥션1                                            | 커넥션2                           |
| :-------- | :------------------------------------------------- | :-------------------------------- |
| 1         | BEGIN                                              |                                   |
| 2         | UPDATE tb_child SET fd='changed-100' WHERE id=100; |                                   |
| 3         |                                                    | BEGIN                             |
| 4         |                                                    | DELETE FROM tb_parent WHERE id=1; |
| 5         | ROLLBACK                                           |                                   |
| 6         |                                                    | Query OK                          |

### 설명

- 커넥션1이 `tb_child` 테이블의 id=100 레코드를 수정하면서 **쓰기 잠금**을 잡는다.
- 이 상태에서 커넥션2가 `tb_parent` 테이블에서 id=1 레코드를 삭제하려고 한다.
- 하지만 `tb_child` 테이블에서 해당 pid=1을 참조하고 있어서,  
  부모 레코드 삭제는 자식 레코드에 대한 잠금이 해제될 때까지 **대기**한다.

> 이는 `ON DELETE CASCADE` 제약 조건으로 인해,  
> 부모 레코드를 삭제하면 자식 레코드도 함께 삭제되어야 하기 때문이다.

<br>

### 주의 사항

- 외래키로 인한 잠금 경합을 고려하여 설계해야 한다.
- 필요한 경우 외래키 없이 애플리케이션 레벨에서 참조 무결성을 관리하는 것도 고려할 수 있다.
- 대규모 테이블에서는 외래키로 인한 연쇄적인 잠금 대기 현상에 주의해야 한다.
