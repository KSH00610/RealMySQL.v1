# Real MySQL 8.5 ~ 8.10

# 8.5 전문 검색 인덱스

- Intro
  - 이전까지의 인덱스 알고리즘은 작은 값에 대한 알고리즘 : B-Tree만 놓고 보더라도 실제 컬럼의 값을 전체 인덱스 키로 사용하는 것이 아닌 특정 값만 짤라서 인덱스 키로 활용, 전체 일치 및 좌측 일부 일치 등 같은 검색만 가능
  - 문서 내용 전체 인덱스화해 특정 키워드 포함된 문서 검색하는 전문(Full Text) 검색은 일반적인 B-Tree 인덱스 사용 X
  - 전문 검색 인덱스 : 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘
- 8.5.1 인덱스 알고리즘

  - 전문 검색 : 문서 본문 내용 내 사용자 검색할 키워드 분석, 빠른 검색용으로 사용하는 키워드로 인덱스 구축 크게 어근 분석과 n-gram 분석 알고리즘으로 구성

    1. 어근 분석 알고리즘

       1. 불용어 처리 : 가치없는 단어 필터링해서 제거하는 작업 → 불용어 갯수가 적기에 상수로 정의해서 사용 or 불용어 자체를 데이터베이스화해서 사용자 추가 삭제하도록 구현 cf) 이미 MySQL 서버에는 불용어가 소스코드로 정의 But 사용자가 별도로 구성하는 것을 추천
       2. 어근 분석 : 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업 → 단어가 복수형, 과거형, 진행형 등으로 변화해도 그 “본래의 의미”를 가진 형태 하나로 통일

          ex)

          | 사용자가 검색한 단어 | 어근 분석후 |
          | -------------------- | ----------- |
          | running              | run         |
          | runs                 | run         |
          | ran                  | run         |
          | studies              | study       |
          | studying             | study       |
          | better               | good        |

       - 이것을 왜 하는가?? : 단어의 형태만 다를 뿐 의미가 같다면 검색 결과도 같아야 하니까 → 위의 예시 중 사용자가 running 검색 시 DB에 저장된 문서에 run이라고 되어 있다면 둘이 매칭되어야 검색이 되는 것
       - 어근 분석을 통해 인덱싱을 어떻게 하는가
         1. 문서 본문에서 모든 단어를 읽는다.
         2. 각 단어에 대한 어근 분석을 진행
         3. 어근을 기준으로 인덱싱
            즉 DV에 저장된 인덱스는 변형된 형태가 아닌 어근으로 저장
       - 어근 분석법 2가지
         | 구분 | 설명 | 예시 | 특징 |
         | ------------- | --------------------------------------- | ------------- | ------------------------- |
         | Stemming | 단어 끝을 단순히 자르는 기법 | running → run | 빠르지만 부정확할 수 있음 |
         | Lemmatization | 단어를 정확한 ‘원형 사전’을 참고해 변환 | better → good | 정확하지만 느림 |

       DB나 검색 엔진에서는 보통 빠른 처리 떄문에 Stemming(어간 추출)을 많이 사용, MySQL의 FullText Index나 ES도 보통 Stemming 기본으로 설정

       - MeCab이란
         - 일본에서 개발된 오픈 소스 형태소 분석기 cf) 형태소 분석 = 문장을 의미 있는 최소 단위(형태소)로 분해하는 것
         - 텍스트를 단어 단위로 쪼개고 품사를 분석하는데 사용
         - 주로 일본어, 한국어와 같은 어절 경계가 불분명한 언어를 다룰 떄 필요
       - 왜 MeCab 사용하는가
         - 한국어/일본어는 영어처럼 단어 사이 공백 존재 X → 단순 공백 기준으로 split하면 제대로 단어를 분리할 수 없다. ex) “나는 밥을 먹었다” → 단순 공백으로 나누는 것이 아닌 “나/는”, “밥/을”, “먹/었/다”처럼 쪼개야됨
         - MySQL Full-Text Search는 기본적으로 영어 최적화 → 한국어나 일본어 검색 품질 낮음, 따라서 MeCab같은 형태소 분석기를 붙여 정확한 단어 인식 가능케 한다.
       - MeCab은 어떻게 동작하는가
         1. 문장 입력
         2. 문장 형태소 단위로 쪼갬(이절 + 품사 분석)
         3. 필요없는 품사(조사, 어미 등) 제거 후 핵심 단어만 남김
         4. 인덱스 생성해 활용하거나 검색에 사용
       - 예시
         - 입력 : 나는 밥을 먹었다
         - MeCab 형태소 분석 결과
           | 형태소 | 품사 |
           | ------ | --------- |
           | 나 | 명사 |
           | 는 | 조사 |
           | 밥 | 명사 |
           | 을 | 조사 |
           | 먹 | 동사 |
           | 었 | 과거 시제 |
           | 다 | 종결 어미 |
           → 명사, 동사만 추출해 인덱스 키워드로 사용(즉 ‘나’, ‘밥’, ‘먹’이 남음)
       - 요약
         - MySQL은 영어 기반이라 한국어/일본어 검색 품질 낮다
         - 이를 보완하기 위해 MeCab과 같은 형태소 분석기 연동해 훨씬 정확한 검색 결과 얻을 수 있다.
         - 특히 불용어 제거, 어근 분석, 정확한 단어 경계 찾기 쉬워진다.
         - 실제 대규모 검색 시스템에서는 DB 인덱스 구축 전처리 단계에서 많이 이용

    2. n-gram 알고리즘
       - 형태소 분석이 문장을 이해하는 알고리즘, n-gram은 단순히 키워드 검색하기 위한 인덱싱 알고리즘
       - 무조건 몇 글자씩 잘라서 인덱싱하는 방법 → 알고리즘 단순, 국가별 언어에 대한 이해와 준비 작업이 필요없다.
       - 만들어진 인덱스의 크기는 상당히 크다.
       - n-gram에서 n은 인덱싱할 키워드의 최소 글자 수, 일반적으로 2글자 단위로 쪼개서 인덱싱하는 2-gram 방식 많이 이용
       - 예시
         - 입력 : To be or not to be. That is the question
           | 단어 | bi-gram(2-gram) 토큰 | | | | | | |
           | -------- | -------------------- | --- | --- | --- | --- | --- | --- |
           | To | To | | | | | | |
           | be | be | | | | | | |
           | or | or | | | | | | |
           | not | no | ot | | | | | |
           | to | to | | | | | | |
           | be | be | | | | | | |
           | That | Th | ha | at | | | | |
           | is | is | | | | | | |
           | the | th | he | | | | | |
           | question | qu | ue | es | st | ti | io | on |
         - 출력
           | 입력 | 불용어 일치 | 불용어 포함 | 출력(최종 인덱스 등록) |
           | ---- | ----------- | ----------- | ---------------------- |
           | To | O | | |
           | be | O | | |
           | or | O | | |
           | no | | | no |
           | ot | | | ot |
           | to | O | | |
           | be | O | | |
           | Th | | | Th |
           | ha | | O | |
           | at | | O | |
           | is | | O | |
           | th | | | th |
           | he | | | he |
           | qu | | | qu |
           | ue | | | ue |
           | es | | | es |
           | st | | | st |
           | ti | | O | |
           | io | | O | |
           | on | O | | |
         - MySQL 서버는 이렇게 생성된 토큰들에 대해 불용어 걸러내는 작업 수행 → 동일하거나 포함하는 경우 걸러서 버림(information_schema.innodb_ft_default_stopword 테이블 통해 불용어 확인 가능) → 일반적으로 MySQL 내장된 불용어 존재하지만 일반적으로 사용하지 않고 사용자가 별도로 정의해 사용하는 것이 일반적
    3. 불용어 변경 및 삭제

       - Intro : 불용어 처리는 사용자를 혼란스럽게 하는 요소로 작용할 수 있음 → 불용어 처리를 완전히 무시하거나 MySQL 서버 내장된 불용어 대신 사용자가 직접 불용어 등록하는 방법 권장
       - 전문 검색 인덱스의 불용어 처리 무시
         1. MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어 완전히 제거 → MySQL 설정 파일(my.cnf)의 ft_stopword_file 시스템 변수 빈 문자열 → ft_stopword_file=’ ’ → 스토리지 엔진 종류 관계없이 모든 테이블에서 내장 불용어 사용 X
         2. InnoDB 스토리지 엔진 사용 전문 검색 인덱스에 대해 불용어 처리 무시 → innodb_ft_enable_stopword = OFF → 이 경우 다른 스토리지 엔진(MyISAM) 사용하는 테이블 여전히 내장 불용어 사용
       - 사용자 정의 불용어 사용

         1. 불용어 파일 저장, 설정에서 파일 경로로 등록 → ft_stopword_file = ‘/data/my_custom_stopword.txt’
         2. InnoDB 스토리지 엔진에서만 사용, 불용어 목록을 테이블로 저장

            ```sql
            mysql> CREATE TABLE my_stopword(value VARCHAR(30)) ENGINE = INNODB;
            mysql> INSERT INTO my_stopword(value) VALUES ('MySQL');

            mysql> SET GLOBAL innodb_ft_server_stopword_table='mydb/my_stopword';
            mysql> ALTER TABLE tb_bi_gram ADD FULLTEXT INDEX fx_title_body(title, body) WITH PARSER ngram;
            ```

- 8.5.2 전문 검색 인덱스의 가용성

  - 전문 검색 인덱스 사용 시 갖춰야하는 2가지 조건

    1. 쿼리 문장이 전문 검색ㅇ르 위한 문법(MATCH, AGAINST, …) 사용
    2. 테이블이 전문 검색 대상 컬럼에 대해 전문 인덱스 보유
       예시)

    ```sql
    CREATE TABLE tb_test (
    	doc_id INT,
    	doc_body TEXT,
    	PRIMARY KEY (doc_id),
    	FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
    ) ENGINE = InnoDB;

    mysql> SELECT * FROM tb_test WHERE doc_body LIKE '%애플%'
    --> 전문 인덱스 활용한 효율적인 쿼리 실행이 아닌 풀 테이블 스캔

    mysql> SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST ('애플' IN BOOLEAN MODE);
    --> 전문 검색 인덱스 활용하기 위해 전문 검색 인덱스 구성하는 컬럼들을 MATCH 절의 괄호 안에 모두 명시
    ```

# 8.6 함수 기반 인덱스

- Intro
  - 인덱스는 값 일부(칼럼의 값 앞부분) 또는 전체에 대해서 인덱스 생성 허용
  - 때로는 칼럼의 값 변형해서 인덱스 구축할 필요 有 → MySQL 8.0부터 함수 기반 인덱스 지원
    1. 가상 칼럼 이용 인덱스
    2. 함수 이용 인덱스
- 가상 칼럼 이용한 인덱스

  - 가상 컬럼이란 : 물리적으로 저장되지 않고 다른 컬럼을 계산해 동적으로 만들어지는 컬럼 → 테이블 안에 별도로 데이터가 저장되지 않고 SELECT 시 계산하는 식
    예시)

  ```sql
  CREATE TABLE user (
  	user_id INT,
  	first_name VARCHAR(10),
  	last_name VARCHAR(10),
  	PRIMARY KEY (user_id)
  ) ENGINE = InnoDB;

  mysql> ALTER TABLE user ADD full_name VARCHAR(30) AS (CONCAT(first_name,'',last_name)) VIRTUAL, ADD INDEX ix_fullname (full_name);
  --> full_name 이라는 가상 컬럼에 대해 검색도 새로 만들어지 ix_fullname 인덱스를 이용해 실행 계획이 만들어짐
  ```

  - 옵션
    | 구분 | VIRTUAL | STORED |
    | --------------------- | ------------------------------------ | ---------------------------------- |
    | 저장 방식 | 물리적으로 저장하지 않음 (동적 계산) | 실제 디스크에 저장함 |
    | 조회 속도 | 느릴 수 있음 (매번 계산 필요) | 빠름 (읽기만 하면 됨) |
    | 디스크 사용량 | 없음 (공간 절약) | 있음 (컬럼 값도 저장) |
    | 인덱스 생성 가능 여부 | 가능 | 가능 |
    | 특징 | 항상 최신 데이터 계산 가능 | INSERT / UPDATE 시점에 계산해 저장 |

- 함수를 이용한 인덱스
  예시)

  ```sql
  CREATE TABLE user (
  	user_id INT,
  	first_name VARCHAR(10),
  	last_name VARCHAR(10),
  	PRIMARY KEY (user_id),
  	INDEX full_name (CONCAT(first_name,'',last_name))
  ) ENGINE = InnoDB;

  --> 함수를 직접 사용하는 인덱스는 테이블 구조 변경하지 않고 계산된 결과값의 검색을 빠르게 만듬
  --> 함수 기반 인덱스 활용하기 위해서는 조건절에 함수 기반 인덱스에 명시된 표현식 그대로 사용
  --> 함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식 다르면 MySQL 옵티마이저는 다른 표현식으로 간주해 함수 기반 인덱스 활용 못함
  ```

# 8.7 멀티 벨류 인덱스

- Intro

  - 전문 검색 인덱스 제외 모든 인덱스는 레코드 1건이 1개 인덱스 키 값 가짐 → 인덱스 키와 데이터 레코드는 1:1 관계
  - 멀티 벨류 인덱스 : 하나의 데이터 레코드 여러 개의 키 값 가진 형태 인덱스 → 일반적인 RDBMS 기준으로 정규화에 위배 → But 최근 RDBMS들이 JSON 데이터 타입 지원하기 시작하면서 JSON 배열 타입 필드 저장된 원소(Element)에 대한 인덱스 요건 발생
    예시)

    ```sql
    CREATE TABLE user (
    	user_id INT,
    	first_name VARCHAR(10),
    	last_name VARCHAR(10),
    	credit_info JSON,
    	INDEX mx_creditscores ( (CAST(credit_info -> '$.credit_scores' AS UNSIGNED ARRAY)) )
    ) ENGINE = InnoDB;

    mysql> INSERT INTO user VALUES(1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}' );

    --> 함수를 직접 사용하는 인덱스는 테이블 구조 변경하지 않고 계산된 결과값의 검색을 빠르게 만듬
    --> 함수 기반 인덱스 활용하기 위해서는 조건절에 함수 기반 인덱스에 명시된 표현식 그대로 사용
    --> 함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식 다르면 MySQL 옵티마이저는 다른 표현식으로 간주해 함수 기반 인덱스 활용 못함
    ```

# 8.8 클러스터링 인덱스

- Intro
  - 여러 개를 하나로 묶는다는 의미로 사용 → 테이블 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태
- 클러스터링 인덱스 : 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것→ 프라이머리 키 값에 의해 레코드 저장 위치 결정 & 프라이머리 키 값 변경되면 레코드 물리적 저장 위치 변경
  - 프라이머리 키 값에 의해 저장 위치 결정되므로 테이블 레코드 저장 방식이라고 볼 수 있다. (클러스터링 인덱스 = 클러스터링 테이브)
  - 클러스터링 기준되는 프라이머리 키 = 클러스터링 테이블
  - 클러스터링 테이블 구조 자체는 일반 B-Tree와 비슷하지만 인덱스의 리프 노드에 레코드의 모든 컬럼이 저장, 즉 테이블 그자체가 하나의 거대한 인덱스 구조로 관리
  - 프라이머리 키가 변경되는 문장 실행 시 → 테이블 안의 레코드 물리적 위치가 바뀐다.
    1. 기존 PK 저장된 레코드 탐색
    2. 해당 레코드 삭제
    3. 새로운 PK 값으로 새로운 위치에 삽입
       → 즉 PK 변경 = 내부적으로 delete + insert : 디스크 I/O 증가, 인덱스 재구성, 트랜잭션 오버헤드, 잠금 경합 가능성 등 매우 무겁고 위험 따라서 실무에서 PK가 절대 변하지 않도록 설계
  - 프라이머리 키 없는 InnoDB → 프라이머리 대체할 컬럼 선택
    1. 프라이머리 키 있으면 기본적으로 프라이머리 키로 클러스터링 키 선택
    2. Not Null 옵션의 유니크 인덱스 중 첫번째 인덱스를 클러스터링 키 선택
    3. 자동으로 유니크한 값 가지도록 증가하는 컬럼을 내부적으로 추가한 후 클러스터링 키 선택
  - 적절한 클러스터링 키 찾지 못하는 경우 : InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 칼럼 생성 → 자동으로 추가된 프라이머리 키는 사용자 노출 X, 쿼리 문장에 명시적 사용 X. 즉 프라이머리 키나 유니크 인덱스 전혀 없는 InnoDB 테이블에서 아무 의미 없는 숫자 값으로 클러스터링, 아무런 혜택 X
- 세컨더리 인덱스에 미치는 영향

  - MyISAM, MEMORY : 클러스터링되지 않은 테이블 INSERT 시 처음 저장된 공간에서 이동 X → 데이터 레코드 저장 주소 = 내부 레코드 아이디(ROWID) & 프라이머리 키, 세컨더리 인덱스 키 주소(ROWID) 이용해 실제 데이터 레코드 찾음(프라이머리 키와 세컨더리 인덱스 간의 구조적 차이 X)
  - InnoDB : 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소 아닌 프라이머리 키 값을 저장

    ```sql
    CREATE TABLE employees (
    	emp_no INT,
    	first_name VARCHAR(20) NOT NULL,
    	PRIMARY KEY (emp_no),
    	INDEX ix_firstname(first_name)
    )

    mysql> SELECT * employees WHERE first_name = 'Aamer'

    --> MyISAM : ix_firstname 인덱스를 검색해 레코드의 주소 확인 후 레코드의 주소 이용해 최종 레코드 가져옴
    --> InnoDB : ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값을 확인 후 프라이머리 키의 인덱스 검색해 최종 레코드 가져옴
    ```

- 클러스터링 인덱스 장단점
  - 장점
    1. PK 검색 시 처리 속도 빠름(특히 PK 범위 검색 시 매우 빠름)
    2. 테이블링 모든 세컨더리 인덱스 보유해 인덱스만으로 처리될 수 있는 경우 많음(커버링 인덱스)
  - 단점
    1. 테이블 모든 세컨더리 인덱스가 클러스터링 키 갖기에 클러스터링 키 값 크기 큰 경우 전체적인 인덱스가 커짐
    2. 세컨더리 인덱스 통해 검색 시 프라이머리 키로 다시 검색해야하므로 처리 성능 느림
    3. INSERT 시 프라이머리 의해 레코드 저장 위치 결정되므로 처리 성능 느림
    4. 프라이머리 키 변경 시 내부적으로 INSERT, DELETE 필요해 처리 성능 느림
  - 요약 : 장점 : 빠른 읽기(SELECT) / 단점 : 느린 쓰기(INSERT, UPDATE, DELETE)
- 클러스터링 테이블 사용 시 주의 사항

  1. 클러스터링 인덱스 크기
     - 클러스터링 인덱스와 세컨더리 인덱스 관계 : InnoDB에서 세컨더리 인덱스도 최종 데이터 레코드 찾기 위해 클러스터링 인덱스 키에 저장 → 세컨더리 인덱스 엔트리 = 세컨더리 키 값 + 클러스터링 키 값
     - 클러스터링 키를 세컨더리 인덱스 저장하는 이용
       - 세컨더리 인덱스만으로 테이블 레코드 완벽히 식별 X
       - 세컨더리 인덱스는 찾기용 실제 데이터는 클러스터링 인덱스 타야지 찾을 수 있다 → 세컨더리 인덱스 엔트리에 PK 추가 저장행 세컨더리 인덱스에서 찾고 바로 PK 통해 테이블 레코드에 접근
     - 프라이머리 키 커질 수록 → 세컨더리 인덱스도 증가 → 세컨더리 인덱스 무거워짐 → 인덱스 I/O 자체가 무거워짐 → 인덱스 I/O 비용 증가(읽어야 하는 페이지 수 증가) → 캐시 효율 감소(버퍼 풀에 적재하는 인덱스 수 감소) → 쿼리 속도 저하(특히 세컨더리 인덱스 스캔)
  2. 프라이머리 키는 Auto-Increment보다 업무적 컬럼으로 생성
     - 기본 배경 : PK를 클러스터링 인덱스로 황요용 → PK는 레코드 저장 순서, 물리적 위치, 정렬 상태 결정
     - Auto-Incremet를 PKㄹ 쓰면
       | 특징 | 설명 |
       | -------------------- | ------------------------------------------------------- |
       | 값이 항상 증가하니까 | 새 레코드가 항상 테이블 마지막에 삽입 |
       | 디스크 I/O 최소화 | 새 레코드 추가할 때 페이지 분할(split) 발생 가능성 낮다 |
       | Insert 성능 | 매우 빠름(순차 insert) |
       → Insert 중심 시스템에서는 Auto-Increment 유리
     - 업무 컬럼(의미 있는 컬럼)으로 PK 잡으면
       | 특징 | 설명 |
       | ------------------------------- | ------------------------------------------------------------- |
       | 특정 업무 데이터 직접 찾기 쉽다 | 예) 주민등록번호, 사번, 주문번호 같은 것 |
       | PK 검색이 빠르다 | 클러스터링 인덱스는 PK로 정렬되어 있어 빠르게 range scan 가능 |
       | 업무 관점에서 자연스럽다 | 데이터 식별이 편하고 외부 시스템 연동도 좋다 |
       → 특히 조회 중심 시스템이나 업무상 식별자 중요한 경우 의미 있는 컬럼을 PK로 쓰는게 유리리
     - 업무 걸럼 PK가 좋은 대표 상황
       | 상황 | 이유 |
       | ----------------------------------- | --------------------------------------------------- |
       | 조회가 많고 Insert 적은 시스템 | PK range scan이 빠르게 가능 |
       | PK 값을 기준으로 Join이 빈번한 경우 | 조인 키를 따로 lookup할 필요 없이 바로 찾을 수 있음 |
       | 데이터 자체가 외부 시스템과 연동 | 의미 있는 값으로 통일해 관리/검색 쉬움 |
       | 인덱스 추가 최소화 목적 | PK 자체가 의미 있어 Secondary Index 줄일 수 있을 시 |
  3. 프라이머리 키는 반드시 명시

     1. 명시하지 않을 시 발생하는 문제점

        | 문제                    | 설명                                                                 |
        | ----------------------- | -------------------------------------------------------------------- |
        | 미의도적 RowID 관리     | 숨겨진 RowID는 개발자가 컨트롤 할 수 없음                            |
        | 데이터 접근 비효율      | 숨겨진 RowID를 이용한 테이블 접근은 비직관적 관리 어려움             |
        | 레코드 정렬 예측 불가   | 테이블 정렬이 자동으로 RowID 기준이 되므로 일정X                     |
        | 외부 시스템 연계 어려움 | PK 명확하지 않으면 다른 테이블이나 시스템에서 JOIN/참조 어려움       |
        | 복구/복제 문제          | 숨겨진 RowID는 서버마다 다를 수 있어 복제/복구 시 일관성 유지 어려움 |

  4. Auro-Increment 칼럼을 인조 식별자로 사용할 경우
     - 여러 개의 칼럼이 복합으로 프라이머리 키가 만든 경우 길어질 경우 있다 → 프라이머리 키가 길어도 세컨더리 인덱스가 필요치 않다면 프라이머리 키 사용하는게 좋다
     - Surrogate Key(인조 식별자) : 업무 상 아무 의미 없는 고유 ID 만들어 PK로 사용 → 세컨더리 인덱스가 필요하고 프라이머리 키가 긴 경우 사용
     - Auto-Increment Surrogate Key 장점
       | 장점 | 설명 |
       | ---------------------------- | ----------------------------------------------------------- |
       | Insert 성능 최적화 | 값이 계속 증가하므로 B+Tree 마지막 삽입, 페이지 분할 최소화 |
       | 인덱스 관리 편함 | PK 크기 작고 고정되어 세컨더리 인덱스도 최적화 가능 |
       | 관계 설정/조인 최적화 | 작은 수치형 데이터 조인 → CPU, 메모리 사용량 적음 |
       | 의미 없는 값이라 유연성 높음 | 업무 변화에도 영향없이 키 유지 |
     - Auto-Increment 단점
       | 특징 | 설명 |
       | ----------------------------- | ---------------------------------------------------- |
       | 키 자체 의미X | 키만 봐서는 레코드 내용이나 의미 유추 X |
       | 추가 제약 필요 | 비즈니스적으로 의미 있는 유일성 따로 Unique Key 관리 |
       | 충돌 가능성(특히 분산 시스템) | 다중 서버에서 Auto-Increment 충돌 가능성 관리 필요 |

# 8.9 유니크 인덱스

- Intro
  - 인덱스보다 제약조건에 가까움 → MySQL에서 인덱스 없이 유니크 제약만 설정할 방법X (유니크 인덱스도 Null 저장 가능, Null 특정 값 아니므로 2개 이상 저장 가능)
- 유니크 인덱스 vs 일반 세컨더리 인덱스
  - 인덱스 읽기
    | 항목 | 유니크 인덱스 | 일반 세컨더리 인덱스 |
    | --------------------- | --------------------------------------------- | ------------------------------------------------------------- |
    | 찾고 싶은 값이 있다면 | 해당 값 찾으면 바로 검색 완료(더 찾을 필요 X) | 찾고 싶은 값을 찾아도 더 탐색 이어가야 할 수 있음 |
    | 탐색 최적화 | 예, 빠르게 탐색 종료 | 아니오, 계속 다음 노드 탐색 |
    | 디스크 I/O | 찾는 작업만 발생 | 찾는 작업 + 필요 없는 추가 탐색 발생 가능 (But CPU 작업 중심) |
    - 유니크 인덱스
      - 찾고자 하는 값 발견 → 탐색 종료 가능(해당 키 값은 테이블에서 유일하게 존재)
      - 디스크 읽기 비용 줄고 CPU 비용 줄어든다.
    - 일반 세컨더리 인덱스
      - 찾고자 하는 값 발견 → 같은 키 가진 다른 레코드 존재 有, 다음 노드도 계속 탐색
      - But 중요한 점은 추가 탐색 = 이미 메로리에 읽은 인덱스 노드(Page) 안에서 CPU로 비료하는 작업 → 디스크 읽기가 아님, 따라서 추가 탐색에 대한 성능 차이 매우 미미(디스크 I/O가 추가로 발생하는 것이 아니므로)
  - 인덱스 쓰기
    - 유니크 인덱스
      | 항목 | 내용 |
      | ------ | -------------------------------------------------- |
      | Insert | 삽입하려는 키 존재 시 미리 검사(유니크 제약 조건) |
      | Update | 키 값 변경 시 새로운 키에 대한 중복 여부 검사 필요 |
      | Delete | 해당 키 값 찾아서 삭제(일반 인덱스 동일) |
      → 즉 항상 중복 체크가 추가로 필요, 단순 삽입/수정이 아닌 존재 여부 먼저 검사하는 읽기 작업(Read-Modify-Write 패턴)이 먼저 발생
    - 일반 세컨더리 인덱스
      | 항목 | 내용 |
      | ------ | --------------------------------------- |
      | Insert | 단순 인덱스에 추가하면 끝 |
      | Update | 변경된 키 값 삭제하고 새로운 키 값 추가 |
      | Delete | 해당 키 값 찾아서 삭제 |
      → 중복 체크 X, 읽기 작업 없이 바로 쓰기 가능
    - MySQL에서 유니크 인덱스에서 중복된 값 체크 시 읽기 잠금 사용하고 쓰기 시 쓰기 잠금 사용 → 이 과정에서 데드락이 빈번하게 발생 & InnoDB 스토리지 엔진에는 인덱스의 키 저장을 버퍼링하기 위해 체인지 버퍼(Change Buffer) 사용, 유니크 인덱스가 일반 세컨더리 인덱스에 비해 쓰기 작업 관련 성능이 떨어짐
- 유니크 인덱스 사용 시 주의 사항
  - 하나의 테이블에서 같은 칼럼으로 유니크, 일반 인덱스 중복 생성 : MySQL에서 같은 역할 → 같은 역할을 하는 것에 대해 중복 생성 시 메모리 잡아먹으므로 주의
  - 동일 컬럼에 대해 프라이머리 키와 유니크 인덱스 생성 : 불필요한 중복 → 메모리 잡아먹으므로 주의

# 8.10 외래키

- Intro
  - InnoDB 스토리지에서만 생성 → 외래키 제약 시 자동으로 연관 테이블 칼럼에 인덱스 생성, 외래키 제거되지 않은 상태에서 자동으로 생성된 인덱스 삭제 X
- 특징
  1. 테이블 변경(쓰기, 잠금) 발생하는 경우에만 잠금 경합(잠금 대기) 발생
  2. 외래키와 연관되지 않은 컬럼 변경은 잠금 경합(잠금 대기) 발생 X
- 자식 테이블 변경 대기하는 경우
  - 자식 테이블의 외래키 칼럼의 변경 시 부모 테이블 확인 필요
  - 만약 부모 테이블 해당 레코드에 쓰기(Insert, Update, Delete) 잠금 걸린 경우 해당 쓰기 잠금 해제될 때까지 대기
- 부모 테이블 변경 작업 대기하는 경우

  - 자식 테이블이 외래 키 칼럼 관련 쓰기 작업 실행 → 해당 레코드에 대한 쓰기 잠금 획득
  - 이후 부모 컬럼에서 해당 컬럼에 쓰기 작업 실행하는 경우 → 자식의 레코드 쓰기 잠금 해제 시까지 대기, 이는 자식 테이블 생성 시 정의된 특성(Delete on Cascade) 때문에 부모 레코드 삭제 시 자식 레코드 또한 동시에 삭제
  - 만약 DELETE ON CASCADE가 없는 경우 아직 자식 레코드가 남아 있으모르 부모 레코드 삭제에 실패한다.
  - Delete on Cascade 있을 때

    1. 트랜잭션 A : 자식 테이블 레코드 수정 → 쓰기 락
    2. 트랜잭션 B : 부모 테이블 레코드 삭제 시도
    3. 부모 레코드 삭제 시 자식 레코드도 삭제해야하므로
    4. 트랜잭션 B는 자식 레코드에 대한 락 해제 시까지 대기(자식 삭제를 위한 Lock 필요)

       → 잠금 대기 발생 (Waiting for Lock)

  - Delete on Cascade 없는 경우

    1. 트랜잭션 A : 자식 테이블 레코드 수정 → 쓰기 락
    2. 트랜잭션 B : 부모 테이블 레코드 삭제 시도
    3. DB 엔진은 부모 레코드 지우기 전

       1. 자식 레코드 존재 여부 확인
       2. 자식 레코드 존재 시 즉시 에러(Cannot delete or update a parent row: a foreign key constraint fails) 반환

       →잠금 대기 없이 바로 실패

       → Lock 경합도 없음
