## 언두 로그

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE) 로 변경되기 이전 버전의 데이터를 별도로 백업
- 5.5 이전 버전의 MySQL 서버는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았음.
- 트랜잭션 관리가 잘못되어 완료가 되지 않은 상태로 시간이 지나게 되면, 트랜잭션 시작 시점부터 생성된 언두 로그를 계속 보존하게 되고, 디스크의 사용량이 점점 증가.

### 언두 테이블스페이스

- 언두 로그가 저장되는 공간
- MySQL 5.6 이전 버전에서 언두 로그는 시스템 테이블스페이스(ibdata.ibd)에 저장
- 시스템 테이블스페이스의 언두 로그 저장 공간은 MySQL 서버가 초기화 될 때 새로 생성되므로 미리 정해진 크기로 할당됨. 이후 언두 로그가 많아져도 자동으로 확장되지 않음.
- 8.0 부터 시스템 테이블스페이스 외부의 별도 로그 파일(undo_001, undo_002…)에 기록됨.

하나의 언두 테이블 스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다.

![image.png](attachment:1fc36a2d-ded4-43ba-8b9f-0ce7a880bc06:image.png)

 

### **롤백 세그먼트(Rollback Segment)**

- **Undo Log들의 집합**
- **목적**:
    - 트랜잭션이 롤백될 때, 데이터를 변경 전 상태로 되돌리기.
    - MVCC를 통해 트랜잭션 격리 수준을 유지하기 위해 이전 버전 데이터를 제공하기.
- **구조**:
    - InnoDB에서는 하나의 **Undo Tablespace**(예: `undo_001.ibd`, `undo_002.ibd`)가 **1~128개의 롤백 세그먼트**를 가질 수 있음.
    

### **언두 슬롯(Undo Slot)**

- 하나의 롤백 세그먼트 내에서 특정 트랜잭션이 사용하는 **개별적인 Undo Log 저장 공간**
- **목적**:
    - 트랜잭션이 수행하는 **변경 작업(INSERT, UPDATE, DELETE)**에 대한 개별적인 언두 정보를 저장.
    - 다중 트랜잭션 환경에서 **각 트랜잭션이 서로 충돌하지 않도록 독립적인 공간 제공**.
- **구조**:
    - 하나의 롤백 세그먼트는 **1개 이상의 언두 슬롯**을 가질 수 있음.
    - 각 슬롯은 개별 트랜잭션의 Undo Log를 저장.

### Undo tablespace truncate

불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것

- `innodb_undo_log_truncate` 시스템 변수가 `on`으로 설정되면, InnoDB 스토리지 엔진의 퍼지 스레드는 주기적으로 언두 로그 공간에서 불필요해진 공간을 잘라(Undo Purge) 운영체제로 반납.

- `innodb_undo_log_truncate` 가 `off` 거나 자동 모드임에도 공간 반납이 부진하다면, 언두 테이블스페이스를 비활성화하여 퍼지 쓰레드가 해당 언두 테이블 스페이스의 불필요한 공간을 운영체제로 반납하도록 할 수 있다.
    1. MySQL을 종료하고 `innodb_undo_tablespaces` 값을 0으로 변경 후 재시작.
    2. 다시 `innodb_undo_tablespaces` 값을 설정하고 재시작하면 새 Undo Tablespace가 생성됨.
    3. 기존에 비대해진 Undo Tablespace가 제거되므로 OS에 공간이 반환됨.
    

 

## 체인지 버퍼

- 레코드가 **INSERT, DELETE, UPDATE** 될 때 **인덱스 페이지도 변경되어야 함**.
- 그러나 **디스크에 대한 랜덤 액세스(Random I/O)가 발생하면 성능이 저하**됨.
- `체인지 버퍼(Change Buffer)`는 **인덱스 페이지가 버퍼 풀에 없는 경우, 변경 사항을 캐싱하는 공간**이다.

체인지 버퍼에 임시로 저장된 레코드 조각은 백그라운드 쓰레드(버퍼 머지 쓰레드)에 의해 병합됨.

5.5 이전 버전까지는 INSERT 작업에 대해서만 가능(그래서 체인지 버퍼를 인서트 버퍼라고 불렀음)

8.0 에서는 INSERT, DELETE, UPDATE로 키가 추가, 삭제 되는 작업에서도 버퍼링 가능하게 됨

유니크 인덱스는 체인지 버퍼를 사용할 수 없음.

결과를 전달하기 전 반드시 중복 체크가 필요하기 때문 

## 어댑티브 해시 인덱스

InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스

매번 B 트리의 루트부터 리프까지 찾아가는 비용이 없어짐.

key: B 트리 인덱스의 고유번호 + B 트리 인덱스의 실제 키 값

value: 데이터 페이지 주소(버퍼 풀 내에 있음 / 버퍼 풀에 없는 정보는 어댑티브 해시 인덱스에서 관리 x)

테이블의 각 인덱스(프라이머리 키, 보조 인덱스 등)은 고유한 식별자(index id)를 부여 받음.

- **※ 왜 AHI 키값이 "인덱스 ID + 키 값" 조합으로 구성될까?**
    
    AHI(Adaptive Hash Index)는 MySQL의 InnoDB 엔진에서 **자주 조회되는 B+Tree 인덱스 키를 해시 테이블에 저장하여 검색 속도를 개선하는 기능**입니다.
    
    💡 **질문 요점:**
    
    > "이미 인덱스 ID가 고유하다면, AHI의 키값으로 '인덱스 ID'만 사용해도 되지 않나?
    > 
    > 
    > 그런데 왜 '인덱스 ID + 키 값' 조합을 키로 쓰는 걸까?"
    > 
    
    정답은 **해시 인덱스가 특정 레코드를 빠르게 찾기 위해서**입니다.
    
    단순히 `인덱스 ID`만으로는 **어떤 키 값을 조회하는지 알 수 없기 때문**입니다.
    
    ---
    
    ## **🔹 인덱스 ID만으로는 키 충돌이 발생함**
    
    InnoDB에서 **각 인덱스(B+Tree)에는 고유한 ID**(Index ID)가 존재하지만,
    
    **같은 인덱스(B+Tree) 내부에서도 수많은 서로 다른 키 값**이 존재합니다.
    
    만약 **AHI의 해시 키가 "인덱스 ID"만으로 구성된다면?**
    
    - 같은 인덱스(B+Tree) 안에 여러 개의 키가 존재하므로, **해시 테이블에서 어떤 키를 찾을지 알 수 없음**.
    - 즉, 특정 레코드를 O(1)로 찾을 수 없고, **추가적인 탐색이 필요하게 됨** → **해시 인덱스의 장점이 사라짐!**
    
    ### **🚨 예제: AHI 키가 "인덱스 ID"만 있을 때 문제점**
    
    ### 📌 `users` 테이블 (Index ID = `105`)
    
    | **id (Primary Key)** | **name (Indexed, Secondary Index)** |
    | --- | --- |
    | 1 | Alice |
    | 2 | Bob |
    | 3 | Charlie |
    
    ### 🔹 **AHI 키값이 "인덱스 ID"만 포함한 경우**
    
    ```
    AHI 키값: 105  ❌ (문제 발생!)
    ```
    
    - `105`는 **users 테이블의 인덱스 ID**이지만, `Alice`를 찾는 건지 `Bob`을 찾는 건지 알 수 없음!
    - 결국 해시 테이블을 통해 즉시 검색할 수 없고, **추가적인 B+Tree 탐색이 필요함** → 해시 인덱스의 효과가 없음.
    
    ---
    
    ## **🔹 "인덱스 ID + 키 값" 조합을 사용하면?**
    
    반면, **AHI 키값을 "인덱스 ID + 키 값"으로 구성하면, 특정 키를 정확히 찾을 수 있음!**
    
    ### 🔹 **AHI 키값이 "인덱스 ID + 키 값"인 경우**
    
    ```
    AHI 키값: (105, "Alice") ✅
    
    ```
    
    - **이제 해시 테이블에서 (105, "Alice")라는 키를 O(1)로 바로 찾을 수 있음!**
    - **동일한 인덱스(105) 내에서도 특정 키 값에 대한 검색을 즉시 처리 가능!**
    
    ### **🚀 예제: "인덱스 ID + 키 값" 조합을 사용한 경우**
    
    ### 📌 `users` 테이블 (Index ID = `105`)
    
    | **AHI 키값 (Index ID, Key Value)** | **실제 데이터 (id, name)** |
    | --- | --- |
    | (105, "Alice") | `id=1, name="Alice"` |
    | (105, "Bob") | `id=2, name="Bob"` |
    | (105, "Charlie") | `id=3, name="Charlie"` |
    
    이제 `SELECT * FROM users WHERE name = 'Alice';` 를 실행하면:
    
    - 해시 인덱스에서 **(105, "Alice")를 O(1)로 찾음**.
    - **B+Tree를 다시 탐색할 필요 없이 즉시 레코드를 반환** → 성능 최적화!
    
    ---
    
    ## **🔹 결론**
    
    **AHI의 키값을 "인덱스 ID + 키 값"으로 설정하는 이유는:**
    
    ✔ **같은 인덱스 ID 내에서 여러 개의 키 값이 존재하기 때문!**
    
    ✔ **"인덱스 ID"만 있으면 특정 키 값을 찾을 수 없어서 추가 탐색이 필요해짐.**
    
    ✔ **"인덱스 ID + 키 값" 조합을 사용하면, 특정 인덱스의 특정 키 값을 O(1)로 빠르게 조회 가능!**
    
    ✔ **결과적으로, 해시 인덱스의 목적(빠른 키-값 조회)을 효과적으로 달성할 수 있음.**
    
    ✅ **따라서, AHI 키값은 반드시 "인덱스 ID + 키 값" 조합으로 생성되어야 함!** 🎯
    

- 어댑티브 해시 인덱스가 도움이 되는 경우
    1. 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷하다(디스크 읽기가 많지 않다)
    2. 동등 조건 검색( =, IN 연산자)이 많다
    3. 쿼리가 데이터 중 일부에 집중된다

- 별 도움이 안되는 경우
    1. 디스크 읽기가 많다
    2. 특정 패턴의 쿼리가 많다(조인 / LIKE 검색)
    3. 매우 큰 데이터를 가진 테이블의  레코드를 폭넓게 읽는다

# § 4.3 MyISAM 스토리지 엔진 아키텍처

MySQL 8.0 부터는 InnoDB 스토리지 엔진으로 모든 기능을 구현할 수 있게 되어 MyISAM 스토리지 엔진은 이후 버전에서 없어질 것이다 ㅠㅠ