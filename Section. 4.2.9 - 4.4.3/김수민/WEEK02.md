### Undo Log

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 데이터가 변경되기 이전 버전의 데이터를 별도로 백업한다.이렇게 백업된 데이터를 언두로그 (Undo Log)라고 한다.

- **역할**
    - **트랜잭션 보장**
        
        : 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구한다.
        
    - **격리 수준* 보장**
        
        : 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회할 경우 격리수준에 따라 변경 전 데이터를 반환할 수 있다.
        
    
    .* 격리 수준: 동시에 여러 트랜잭션이 데이터를 변경 또는 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준.
    
- **언두 로그 모니터링**
    
    MySQL 5.5 이전 버전에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다. 대용량 데이터 처리 트랜잭션 뿐 아니라 장시간 실행되는 트랜잭션은 언두로그의 양을 급격히 늘어나게 한다.
    
    → **디스크** 사용량 증가
    
    → 빈번하게 변경된 레코드 조회 시 InnoDB 스토리지 엔진은 언두로그 이력을 필요한 만큼 스캔해야 필요한 레코드를 찾을 수 있기 때문에 전반적인 쿼리 성능 저하.
    
    MySQL 8.0에서는 언두로그를 돌아가며 순차적으로 사용해 디스크 공간을 줄이는 것도 가능하며, MySQL 서버가 필요한 시점에 사용공간을 자동으로 줄여주기도 한다. 하지만 여전히 활성상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다.
    

- **언두 테이블스페이스* 관리**
    
    MySQL 5.6 이전 버전에서는 언두로그는 모두 시스템 데이블스페이스 (`ibdata.ibd`)에 저장됐다.
    
    MySQL 5.6버전에서는 `innodb_undo_tablespaces` 시스템 변수가 도입됐다. 변수 값을 2 이상으로 설정하면 InnoDB 스토리지 엔진은 별도의 언두로그 파일을 사용한다. 0으로 설정하면 5.6 이전 버전과 동일하게 동작한다.
    
    MySQL 8.0부터 언두로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선되었다.
    
    - **언두 테이블 스페이스 구성**
        
        하나의 언두 테이블스페이스는 1개 이상 128개 이하 롤백 세그먼트를 가짐
        
        하나의 롤백 세그먼트는 1개 이상, InnoDB 페이지 크기를 16byte로 나눈 값의 개수만큼 언두 슬롯을 가짐
        
    
    언두로그 공간이 남는 것은 크게 문제되지 않지만 언두로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다. 언두로그 관련 시스템 변수를 변경해야 한다면 적절히 필요한 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트의 개수를 설정해야 한다.
    
    MySQL 8.0부터 자동 또는 수동으로Undo Tablespace Truncate** 가능 
    
    .* Undo Tablespace: 언두로그가 저장되는 공간
    
    ** Undo Tablespace Truncate: 언두 테이블스페이스 공간을 필요한 만큼만 남기고 남은 공간을 운영체제로 반납하는 것
    

### Change Buffer

`INSERT`, `UPDATE` 시 데이터 파일 변경 뿐 아니라 해당 테이블의 인덱스도 업데이트가 필요하다. 이때, 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하다. 이는 상당히 많은 자원을 소모하는 작업이다.

InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 디스크로부터 읽어와 업데이트를 해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해둔다. 그리고 바로 사용자에게 결과를 반환하는 방식으로 성능을 향상시킨다. 이때 사용하는 임시 **메모리** 공간을 체인지버퍼라고 한다.

유니크 인덱스는 사용자에게 결과 전달 전 반드시 중복 체크를 해야하므로 체인지 버퍼 사용 불가능.

**체인지 버퍼 머지 스레드**: 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각을 병합하는 백그라운드스레드.

체인지 버퍼는 기본적으로 InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있으며, 50%까지 설정 가능하다.

### Redo Log 및 Log Buffer

리두 로그는 ACID 중 영속성 (Durable)과 가장 연관되어 있다.

- **역할**
    - **쓰기 비용이 낮은 자료구조**
    - **서버 비정상 종료 시 기록되지 못한 데이터 복구를 위한 안전장치**

성능을 위해 리두로그를  버퍼링할 수 있는 InnoDB 버퍼 풀, 로그 버퍼와 같은 자료구조도 존재함.

리두 로그를 디스크에 기록하는 작업은 많은 부하를 유발하기 대문에 어느 주기로 디스크에 동기화할지 `innodb_flush_log_at_trx_commit` 시스템 변수로 설정 가능.

로그 버퍼*는 기본 값인 16MB수준에서 설정하는 것이 적합함. BLOB, TEXT 등 큰 데이터를 자주 변경하는 경우 더 크게 설정하는 것이 좋음.

.* 로그 버퍼: 리두 로그 버퍼링에 사용되는 공간

- **리두 로그 아카이빙**
    
    MySQL 8.0부터 추가된 기능.
    
    데이터 백업 시 데이터 파일 복사도중에 추가된 리두로그 엔트리가 함께 백업되지 않는 경우 데이터는 일관된 상태를 유지하지 못한다.
    
    리두로그 아카이빙 기능은 데이터 변경이 많아서 리두로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해준다.
    
- **리두 로그 활성화 및 비활성화**
    
    리두로그는 비정상적 서버 종료 시 트랜잭션 복구를 위해 항상 활성화되어 있다. 즉, 트랜잭션이 커밋되어도 데이터 파일은 즉시 디스크로 동기화되지 않지만 리두로그는 항상 디스크로 기록된다.
    
    MySQL 8.0부터 수동으로 리두로그를 비활성화하여 데이터 적재 시간을 단축할 수 있다.
    

### Adaptive Hash Index

일반적인 인덱스는 사용자가 테이블에 생성한 B-Tree 인덱스를 의미한다

어댑티브 해시 인덱스는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진이 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.

버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다.

(인덱스 키 값* - 데이터 페이지 주소**) 쌍으로 관리된다.

InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재 한다. (파티셔닝 가능)

어댑티브 해시 인덱스도 메모리공간을 사용한다. 또한, 테이블 DELETE또는 ALTER 시 테이블이 가진 모든 데이터 페이지 내용을 어댑티브 해시 인덱스에서 제거해야하므로 상당히 많은 CPU자원이 사용되고, 그만큼 DB 서버 처리 성능이 느려진다.

따라서 어댑티브 해시 인덱스가 서비스 패턴에 맞게 도움이 되는지 불필요한 오버헤드만 만들고있는지 판단이 필요하다.

- **특징**
    
    B-Tree에 비해 단일 검색 성능 좋음 → CPU 연산량 적음 → 쿼리 성능 증가
    
- **어댑티브 해시 인덱스가 성능향상에 큰 의미가 없는 경우**
    
    : 디스크 읽기가 많은 경우, 패턴 검색 쿼리가 많은 경우, 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
    
- **어댑티브 해시 인덱스가 성능에 유리한 경우**
    
    : 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(= 디스크 읽기가 많지 않은 경우), 동등 조건 검색이 많은 경우, 쿼리가 일부 데이터에만 집중되는 경우
    

.* 인덱스 키 값은 B-Tree 인덱스 고유번호 (ID)와 B-Tree 인덱스의 실제 기 값 조합으로 생성된다.

** 인덱스 키 값이 저장된 페이지 주소

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

MySQL 8.0에서는 InnoDB vs MyISAM, MEMORY 스토리지 엔진의 성능상 비교가 의미 없다.

MySQL 8.0에서는 모든 기능이 InnoDB 스토리지 엔진 기반으로 재편됐고, MyISAM 스토리지 엔진만이 가지는 장점이 없다. MEMORY 스토리지 엔진 또한 동시 처리 성능에 있어서 InnoDB 스토리지 엔진을 따라갈 수 없다.

| 항목 | InnoDB | MyISAM | MEMORY |
| --- | --- | --- | --- |
| **채택된 버전** | MySQL 5.5부터 기본 엔진 (현재 유지) | MySQL 8.0부터 비권장 (Deprecated) | 현재 유지 (일시적 데이터 저장용) |
| **미래 전망** | 지속적으로 개선 및 유지보수됨 | 사용이 점점 줄어드는 추세 (대체됨) | 특정 용도(세션, 캐시)로 유지 |
| **트랜잭션 지원** | O (ACID, MVCC) | X | X |
| **잠금 방식** | **레코드(행) 단위 잠금** (Row Lock) | **테이블 단위 잠금** (Table Lock) | **테이블 단위 잠금** (Table Lock) |
| **외래 키(Foreign Key)** | O | X | X |
| **데이터 저장 방식** | 디스크 기반 (클러스터형 인덱스) | 디스크 기반 (비클러스터형 인덱스) | 메모리 기반 (휘발성) |
| **데이터 복구 기능** | O (Crash Recovery) | X | X |
| **읽기 성능** | **느림 (행 잠금으로 동시성 높음)** | **빠름 (테이블 잠금으로 단순 구조)** | **매우 빠름 (메모리 사용)** |
| **쓰기 성능** | **빠름 (동시성 처리 우수)** | **빠름 (단순 구조, 테이블 잠금 영향)** | **매우 빠름 (메모리 사용)** |
| **인덱스 유형** | 클러스터형 인덱스 (PRIMARY KEY가 데이터와 함께 저장) | 비클러스터형 인덱스 (인덱스만 저장) | 해시(Hash) 및 B-Tree 인덱스 |
| **지원되는 주요 용도** | 트랜잭션이 필요한 OLTP 시스템 | 읽기 중심(검색 엔진, 로그) | 세션 관리, 캐싱 |
| **대표적인 활용 사례** | 금융, 전자상거래, ERP | 데이터 분석, 검색 시스템 | 빠른 임시 데이터 저장 (JOIN 최적화) |

## 4.3 MyISAM 스토리지 엔진 아키텍처

![image](https://github.com/user-attachments/assets/1f3351a7-908a-4ab1-83ae-3c88e5f59ac7)


### 키 캐시

InnoDB 버퍼 풀과 비슷한 역할. 인덱스만을 대상으로 작동하며, 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼 역할을 한다.

### 운영체제의 캐시 및 버퍼

검색의 경우 키 캐시를 이용해 디스크를 검색하지 않고도 빠르게 검색 가능.

디스크로부터 I/O를 해결해줄만한 캐시나 버퍼링 기능 없음.

그래서 테이블 데이터 읽기, 쓰기 작업은 항상 OS의 디스크 I/O 작업으로 요청될 수밖에 없다. 대부분의 OS는 디스크 I/O작업을 위한 캐시나 버퍼링 메커니즘을 탑재하고 잇기 때문에 매번 디스크의 파일을 읽지는 않는다.

### 데이터 파일과 프라이머리 키 (인덱스) 구조

InnoDB 스토리지 엔진을 사용하는 테이블은 PK에 의해 클러스터링되어 저장되지만, MyISAM 테이블은 PK에 의햔 클러스터링 없이 데이터 파일이 힙 공간처럼 활용된다.

레코드는 PK 값과 무관하게 삽입 순서대로 데이터파일에 저장되며 테이블에 저장되는 레코드는 모두 ROWID라는 물리적 주소값을 가진다. PK와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 갖는다.

## 4.4 MySQL 로그 파일

로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식 없이도 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아 해결할 수 있다. MySQL 서버에 문제가 생겼을 때는 다음의 로그 파일들을 자세히 확인하느 습관을 가지자.

### 에러 로그 파일

MySQL 실행 도중 발생하는 에러나 경고 메시지가 출력되는 로그파일

MySQL 설정 파일 `my.cnf` 에서 `log_error` 라는 이름의 파라미터로 정의된 경로에 생성된다.

- **MySQL이 시작하는 과정과 관련된 정보성/에러 메시지**
- **InnoDB 트랜잭션 복구 메시지: 마지막으로 종료 시 비정상적으로 종료된 경우**
- **쿼리 처리 도중에 발생한 문제에 대한 에러 메시지**
- **Aborted Connection: 비정상적으로 종료된 커넥션 메시지**
- **InnoDB 모니터링/상태 조회 명령 결과 메시지**
    
    InnoDB 테이블, 락 모니터링 또는 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 로그 파일에 기록하므로 모니터링 사용 이후 다시 비활성화해주어야 한다.
    
- **MySQL 종료 메시지**
    
    MySQL이 마지막으로 종료되며 출력한 메시지를 통해 종료된 원인을 유추할 수 있다.
    

### 제너럴 쿼리 로그 파일 (제너럴 로그 파일, General log)

쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록해서 MySQL 서버에서 실행되는 쿼리 목록을 검토할 수 있다.

슬로우 쿼리 로그와는 달리 쿼리가 실행되기 전 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중 에러가 발생하더라도 로그에 기록된다.

### 슬로우 쿼리 로그

슬로우 쿼리 로그 파일에는 `long_query_time` 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다. 이는 서비스 운영 중 성능 저하의 원인이 되는 쿼리를 판단하는데 큰 도움이 된다.

MySQL이 쿼리를 실행하고 실제 소요된 시간을 기준으로 기록되므로 반드시 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에 기록될 수 있다.

- **로그 파일 분석 툴**
    
    슬로우 쿼리 또는 제너럴 로크 파일이 상당히 많아 직접 쿼리를 하나씩 검토하기 어려운 경우 Percona에서 개발한 Percona Toolkit의 `pt-query-digest` 스크립트를 통해 빈도나 처리 성능별로 쿼리를 정렬해 볼 수 있다. 로그 파일 분석이 완료되면 결과는 다음 3개의 그룹으로 나누어저 저장된다.
    
    - **슬로우 쿼리 통계**
        
        : 분석 결과 최상단에 표시됨. 모든 쿼리를 대상으로 슬로우 쿼리 로그의 실행시간, 잠금 대기 시간 등에 대해 평균 및 최소/최대 값을 표시한다.
        
    - **실행 빈도 및 누적 실행 시간순 랭킹**
        
        : 각 쿼리별로 응답 시간과 실행 횟수를 보여준다. `pt-query-digest` 명령 실행 시 `--order-by` 옵션으로 정렬 순서 변경 가능.
        
    - **쿼리별 실행 횟수 및 누적 실행 시간 상세정보**
        
        Query ID별 쿼리를 랭킹에 표시된 순서로 자세한 내용을 보여준다.
