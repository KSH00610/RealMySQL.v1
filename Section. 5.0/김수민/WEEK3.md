# Chapter 5. 트랜잭션과 잠금

- **Transaction**
    
    : ACID 원칙을 통해 데이터의 정합성을 보장하는 역할
    

MySQL **동시성**에 영향을 미치는 부분

- **Lock**
    
    : 여러 커넥션에서 동시에 동일한 자원 변경을 요청할 경우 순서대로 한 시점에 하나의 요청을 처리할 수 있도록 하는 역할
    
- **Isolation level**
    
    : 하나의 트랜잭션 내 또는 여러 트랜잭션 간의 작업 내용을 얼마나 공유하고 배게할 것인지 결정하는 수준
    

## 5.1 트랜잭션

### MySQL에서의 트랜잭션

트랜잭션은 **하나의 논리적인 작업 셋**에 대해 작업 셋의 모든 작업 (Query)이 **100% 적용** (Commit)되거나 **아무것도 적용되지 않아야** (RollBack) 함을 보장해준다.

- **InnoDB vs MyISAM**
    
    트랜잭션을 사용하는 InnoDB는 작업 중 오류가 발생하면 트랜잭션이 시작하기 전 상태로 RollBack을 수행한다.
    
    트랜잭션을 사용하지 않는 MyISAM은 작업 중 오류가 발생하면 오류 발생 전까지 작업된 내용이 테이블에 반영된 채로 남아있을 수 있다.
    
    → MyISAM에서 발생할 수있는 부분 업데이트 (Partial Update)현상은 **테이블 데이터 정합성**을 맞추는 데 어려움을 만든다.
    

### 주의사항

프로그램 코드가 DB 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼있는 범위를 최소화해야 한다. 즉, **꼭 필요한 최소의 코드 범위에만 적용**하는 것이 좋다.

→ **DB 커넥션**은 개수가 제한적이어서 각 단위  프로그램이 커넥션을 소유하는 시간이 길어질 수록 상요 가능한 여유 커넥션의 수는 줄어든다.

→ **네트워크 작업**은 오류 발생 시 웹 서버 뿐 아니라 DBMS까지 악영향을 미칠 수 있으므로 반드시 트랜잭션에서 제거하는 것이 좋다.

→ **단순 데이터 조회**는 트랜잭션에 포함될 필요 없다.

→ 작업 성격이 다른 트랜잭션은 별도의 트랜잭션으로 분리하느 것이 좋다.

## 5.2 MySQL 엔진의 잠금

MySQL에서 사용되는 lock은 크게 다음과 같이 나눌 수 있다.

- **스토리지 엔진 레벨**
    
    : 스토리지 엔진 간 상호 영향을 미치지 않는다.
    
- **MySQL 엔진 레벨**
    
    : 모든 스토리지 엔진에 영향을 미친다.
    

### 글로벌 락

MySQL에서 제공하는 lock 중 가장 범위가 크다.

**MySQL 서버 전체**에 영향을 미치며, 작업 대상 테이블이나 DB가 다르더라도 동일하게 적용된다. MySQL 서버의 모든 테이블에 큰 영향을 미치므로 서비스용 MySQL서버에서는 가급적 사용하지 않는 것이 좋다.

### 테이블 락

개별 테이블 단위로 설정되는 lock이며, **명시적** 또는 **묵시적**으로 특정 테이블의 lock을 획득할 수 있다.

명시적으로 테이블을 잠그는 작업은 글로벌 lock과 동일하게 온라인 작업에 상당한 영향을 미치므로 특별한 상황이 아니라면 애플리케이션에서 사용할 필요가 없다.

묵시적 lock은 MyISAM이나  MEMORY 테이블에 데이터 변경 쿼리를 실행하면 발생한다. InnoDB 테이블은 스토리지 엔진 차원에서 **레코드 기반 잠금**을 제공하기 때문에 DML 쿼리에서는 무시되고 DDL의 경우에만 묵시적 lock이 설정된다.

명시적 lock은 획득 후 lock 반납 (해제) 필요, 묵시적 lock은 쿼리 완료 후 자동 해제됨.

명시적 테이블 lock은 MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다.

### 네임드 락

`GET_LOCK()` 함수를 이용해 임의의 **문자열에 대해 잠금**을 설정할 수 있다. 테이블, 레코드, DB객체 등이 아니라 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 lock이다. 자주 사용되지 않는다.

**여러 클라이언트가 상호 동기화를 처리해야 하는 경우** 또는 **많은 레코드에 대해 복잡한 레코드 변경이 있는 트랜잭션**에 유용하게 사용할 수 있다.

### 메타데이터 락

테이블이나 뷰 같은 **DB 객체의 이름이나 구조를 변경하는 경우 획득**하는 lock이다. 명시적으로 획득 또는 해제할 수 있는 것은 아니고, 자동으로 획득된다.

## 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 lock과 별개로 스토리지 엔진 내부에 **레코드 기반의 lock 방식**을 탑재하고 있다. InnoDB는 레코드 기반의 lock방식으로 인해 MyISAM보다 훨씬 **뛰어난 동시성 처리**를 제공할 수 있다.

이원화된 잠금 처리로 InnoDB 스토리지 엔진에서 사용되는 lock정보는 MySLQ 명령을 이용해 접근하기 상당히 까다로웠다. 하지만 최근 버전에서는 lock 모니터링이 강화되고 InnoDB 스토리지 엔진 내부 잠금(세마포어)에 대한 모니터링 방법도 추가됐다.

### InnoDB 스토리지 엔진의 잠금

![image.png](attachment:a025ee47-9533-464c-bf4f-9e6e62c47310:image.png)

InnoDB 스토리지 엔진은 **레코드 기반의 lock**을 제공하며, lock 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락 또는 테이블 락으로 레벨업 되는 경우 (**락 에스컬레이션**)는 없다.

- **레코드 락**
    
    **레코드 자체만을 잠그는 lock.**
    
    다른 상용 DB와 동일하지만, 레코드 자체를 잠그는 것이 아니라 **인덱스를 잠근다**는 점에서 차이가 있다.
    
- **갭 락**
    
    다른 DBMS와의 차이점.
    
    레코드 자체가 아니라, **레코드와 인접한 레코드 사이의 간격만 잠그는 lock.**
    
    레코드와 레코드 사이에 새로운 레코드가 INSERT되는 것을 제어한다. 이보다는 넥스트 키 락의 일부로 자주 사용된다.
    
- **넥스트 키 락**
    
    **레코드 락 + 갭 락**
    
    InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
    
    그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랙잭션을 기다리게 만드는 일이 자주 발생하므로 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔서 락을 줄이는 것이 좋다.
    
- **자동 증가 락**
    
    AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다. 이를 위해 InnoDB 스토리지 엔진에서는 내부적으로 AUTO_INCREMENT 락이라는 **테이블 수준의 lock**을 사용한다.
    
    INSERT와 REPLACE 같은 새로운 레코드 저장을 위한 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다. **AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제**된다.
    
    AUTO_INCREMENT lock은 **테이블에 단 하나만 존재**하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 락을 걸면 다른 쿼리는 락을 기다려댜 한다.
    
    명시적으로 획득, 해제할 수 없다.
    
    MySQL 5.1 이상부터는 `innodb_autoinc_lock_mode` 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.
    

### 인덱스와 잠금

InnoDB lock은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.

이런 방식으로 인해 **변경이 필요한 레코드를 찾기 위해 인덱스 필드로 검색되었던 레코드들에 모두 락을 걸어야 한다.** UPDATE 문장을 위한 적절한 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 변경하지 못하고 기다려야 할 것이다. InnoDB에서 인덱스 설계가 중요한 이유이다.

ex) 테이블에 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 UPDATE 작업을 하게 되고, 이 과정에서 모든 레코드를 잠그게 된다.

### 레코드 수준의 자금 확인 및 해제

테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 쉽게 문제가 발견되고 해결될 수 있지만, 레코드 수준의 잠금은 그 레코드가 자주 사용되지 않는다면 오랜 시간동안 잠긴 상태로 남아 있어도 잘 발견되지 않는다.

MySQL 5.1부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해보면 잠금과 잠금 대시를 바로 확인할 수 있다. lock을 강제로 해제하려면 `KILL` 명령어로 스레드를 강제종료하면 된다.

## 5.4 MySQL의 격리 수준

![image.png](attachment:a60c94bf-0e8d-4163-bf30-4403874eba8f:image.png)

아래로 갈 수록 **격리 (고립) 수준**은 높아지고 **동시 처리 성능**은 떨어지는 것이 일반적이다.

READ UNCOMMITED는 일반적인 DB에서는 거의 사용되지 않고, SERIALAZABLE은 동시성이 중요한 DB에서는 거의 사용되지 않는다.

**오라클은 READ COMMITED, MySQL은 REPEATABLE READ**를 주로 사용한다.

### READ UNCOMMITTED

다른 트랜잭션에서 **커밋되지 않은 데이터도 읽을 수 있음** (Dirty Read 허용)

### READ COMMITTED

**커밋된 데이터만 읽을 수 있음**, 하지만 같은 쿼리 내에서도 값이 바뀔 수 있음 (Non-repeatable Read 허용)

### REPEATABLE READ

**트랜잭션 내 동일한 쿼리는 항상 같은 결과 반환**, 하지만 Phantom Read는 발생할 수 있음

### SERIALIZABLE

**모든 트랜잭션을 순차적으로 처리**, 가장 엄격하지만 동시성은 가장 낮음 (모든 읽기에 락 발생)