# 8.2 인덱스란

많은 사람이 인덱스를 책의 맨 끝에 있는 찾아보기(또는 "색인")으로 설명한다. 책의 마지막에 있는 "찾아보기" 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있다.

책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 **레코드의 주소에 비유**될 것이다.

DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 **칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것이다.**

책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾는데, 시간이 걸린다. 그래서 최대한 빠르게 찾아갈 수 있게 정렬되어 있는데, **DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관**한다.

SortedList와 ArrayList라는 자료 구조는 많이 들어봤을 것이다. SortedList는 DBMS의 인덱스와 같은 자료 구조이며, ArrayList는 데이터 파일과 같은 자료 구조를 사용한다. SortedList는 저장되는 값을 항상 정렬된 상태로 유지하며, ArrayList는 값을 저장되는 순서 그대로 유지하는 자료 구조이다.

**DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지**한다. **데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장**해 둔다.

SortedList의 장단점을 통해 인덱스의 장단점을 알아보자. SortedList 자료 구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어 아주 빨리 원하는 값을 찾아올 수 있다. DBMS의 인덱스도 인덱스가 많은 테이블은 당연히 `INSERT`, `UPDATE`, `DELETE` 문장의 처리가 느려진다. 하지만, 이미 정렬된 "찾아보기"용 표(인덱스)를 가지고 있기 때문에 `SELECT` 문장은 매우 빠르게 처리할 수 있다.

결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이기는 기능이다. 여기서도 알 수 있듯 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다. **`SELECT` 쿼리 문장의 `WHERE` 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.**

## 8.2.1 인덱스의 역할 별 분류

인덱스는 데이터를 관리하는 방식과 중복 값의 허용 여부 등에 따라 여러 가지로 나눠볼 수 있다. 이 문서에서는 키라는 말과 인덱스는 같은 의미로 사용하겠다. 인덱스를 역할 별로 구분해 본다면 `프라이머리 키`와 `보조 키`로 구분할 수 있다.

- 프라이머리 키는 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류.

## 8.2.2 데이터 저장 방식 별 분류

데이터 저장 방식 별로 구분할 경우 사실 상당히 많은 분류가 가능하겠지만 대표적으로 `B-Tree` 인덱스와 `Hash` 인덱스로 구분할 수 있다. 최근에는 `Fractal-Tree` 인덱스나 로그 기반의 `Merge-Tree` 인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다. 물론 이 외에도 수많은 알고리즘이 있지만 대표적으로 시중의 RDBMS에서 많이 사용하는 알고리즘은 이 정도일 것이다.

- B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, 상당히 오래전에 도입된 알고리즘이며 그만큼 성숙해진 상태이다. B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다. **Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용**한다.

## 8.2.3 데이터 중복 허용 여부 분류

유니크 인덱스와 유니크하지 않은 인덱스로 구분이 가능한데, 이는 DBMS에게 꽤나 큰 의미가 된다.

**유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과**를 낸다. 그 뿐만 아니라 유니크 인덱스로 인한 MySQL의 처리 방식의 변화나 차이점이 상당히 많다. 이 부분은 뒷 장의 인덱스와 쿼리의 실행 계획을 살펴보며 배울 것이다.
