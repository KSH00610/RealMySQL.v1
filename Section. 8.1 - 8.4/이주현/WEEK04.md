# § 8.2 인덱스

DBMS가 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸리기 때문에  
칼럼(칼럼들)의 값과 해당 레코드가 저장된 주소를 key-value pair로 만들어 놓은 것을 인덱스라고 함.

인덱스는 칼럼의 값을주어진순서로 미리 정렬해서 보관한다.

데이터를 저장할 때마다 값을 정렬해야 하므로 INSERT, UPDATE, DELETE 의 처리가 느려지지만  
SELECT의 처리가 매우 빨라진다.

## 인덱스의 분류

### 역할

- 프라이머리 키(Primary key)
  레코드를 대표하는 칼럼의 값으로 만들어진 인덱스  
   Not Null, Unique

- 보조 키(Secondary key)
  프라이머리 키를 제외한 모든 인덱스

### 데이터 저장 방식(알고리즘)

- B-Tree 인덱스
  칼럼의 값을 변경하지 않고 인덱싱

- Hash 인덱스
  칼럼의 값을 해싱하여 인덱싱  
   검색이 매우 빠르나 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색할 수 없음.

### 데이터 중복 허용

- 유니크 인덱스(Unique index)
- 유니크 하지 않은 인덱스(Non-Unique index)

# § 8.3 B-Tree 인덱스

일반적으로 DBMS에서는 주로 B+ Tree / B\* Tree 가 사용된다.  
<br>
![B+ Tree 인덱스 구조](/Section.%208.1%20-%208.4/이주현/images/8.4.png)

인덱스의 키 값은 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않다.  
<br>

---

<br>

![MyISAM B-Tree 인덱스](/Section.%208.1%20-%208.4/이주현/images/8.5.png)  
MyISAM의 인덱스에서는 인덱스 키에 대한 값이 ROWID(레코드 물리 주소)를 갖는 반면  
<br>

---

<br>

![InnoDB B-Tree 인덱스](/Section.%208.1%20-%208.4/이주현/images/8.6.png)

InnoDB에서는 ROWID 대신 프라이머리 키 값을 갖는다.  
프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 노드에 저장되어 있는 레코드를 읽는다.  
<br>

## § 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### § 8.3.2.1 인덱스 키 추가

새로운 키 값이 B-Tree에 저장될 때는 저장될 위치를 검색해야한다.  
리프 노드가 꽉 차서 더 저장할 수 없을 때에는 리프 노드를 split 해야 하는데,  
이러한 작업 때문에 B-Tree는 상대적으로 쓰기 작업에 큰 비용이 든다.

인덱스 추가로 인해 INSERT나 UPDATE가 어떤 영향을 받는지에는 테이블 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 등을 확인해야 하나,  
대략 테이블에 레코드를 추가하는 작업 비용을 1이라고 했을 때, 인덱스에 키를 추가하는 작업 비용을 1.5로 예측할 수 있다.  
이 비용의 대부분은 메모리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰는 시간이다.

MyISAM 이나 MEMORY 스토리지 엔진에서는 INSERT가 실행되면 즉시 새 키 값을 B-Tree 인덱스에 반영하지만,
InnoDB 스토리지 엔진은 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. (but 프라이머리 키, 유니크 인덱스의 경우 중복 체크가 필요해 즉시 반영)  
<br>

### § 8.3.2.2 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크  
삭제 마킹된 인덱스 키 공간은 방치되거나 재활용 될 수 있다.  
<br>

### § 8.3.2.3 인덱스 키 변경

인덱스의 키 값은 그 값에 따라 저장될 위치가 결정되므로 인덱스 키 값이 변경되는 경우  
단순히 인덱스 키 값만 변경하는 것이 불가능

인덱스 키 값을 삭제한 후, 새로운 키 값을 추가하는 형태로 이루어짐.  
<br>

### § 8.3.2.4 인덱스 키 검색

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따른 비용을 감수하는 이유는 빠른 검색을 위함이다.

B-Tree 인덱스를 이용한 검색은

- 100% 일치 조건에서 사용할 수 있다.
- 값의 앞부분(Left-most part) 일치 조건에서 사용할 수 있다.
- 부등호 비교 조건에서 사용할 수 있다.
- 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다.
- 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 사용할 수 없다.

<br>

## § 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기, 레코드 건 수, 유니크한 인덱스 키 값의 개수 등

### § 8.3.3.1 인덱스 키 값의 크기

디스크에 데이터를 저장하는 기본 단위는 페이지(Page) 또는 블록(Block).  
한 번의 읽기/쓰기 작업은 페이지 단위로 이루어짐. (보통 16KB)

페이지 크기와 키 값 크기에 따라 B-Tree의 자식 노드 개수가 결정된다.

하나의 인덱스 페이지 안에 여러 개의 키/자식 노드 주소가 저장됨. (그림 8.4 참고)

![인덱스 페이지의 구성](/Section.%208.1%20-%208.4/이주현/images/8.7.png)  
<br>

---

<br>
키 값(1233...ABCD...) + 자식 노드 주소 쌍으로 저장된다.

`키 값 크기가 커지면 저장할 수 있는 키 수가 줄어든다.`  
계산 예시:

키 크기 = 16바이트

자식 포인터 = 12바이트

한 키-포인터 쌍 = 28바이트

16KB 페이지에는 약 16 \* 1024 / 28 ≈ `585개 저장 가능`

만약 키 길이가 두 배(32바이트)로 늘어나면

한 쌍 = 32 + 12 = 44바이트

저장 가능한 개수는 16 \* 1024 / 44 ≈ `372개로 줄어듦.`

-> SELECT 쿼리로 500개의 레코드를 읽을 때 키 값의 크기가 작으면 한 번의 디스크 I/O로 읽어올 수 있지만,  
키 값의 크기가 커지면 2번 접근해야 함.

++ InnoDB는 인덱스 페이지를 메모리에 올리는데, 키 값의 크기가 커지면 한 번에 메모리에 올릴 수 있는 레코드 수도 감소함.

### § 8.3.3.2 B-Tree 깊이

깊이는 상당이 중요하지만 직접 제어할 방법이 없음.  
인덱스 키 값이 커지면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고,  
B-Tree의 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.

### § 8.3.3.3 선택도(기수성)

Selectivity, Cardinality는 거의 같은 의미로 사용됨.  
인덱스 키 값 중 유니크한 값의 수

선택도가 높을 수록 검색 대상이 줄기 때문에 빠르게 처리됨.

```sql
SELECT *
FROM tb_test
WHERE country='KOREA' AND city='SEOUL';
```

전체 row의 개수는 1만 개,
country에만 인덱스가 걸려있다고 해보자.

Case 1. country의 selectivity = 10
-> city = 'SEOUL' 을 비교하기 위해 약 1000개의 row가 검색될 것

Case 2. country의 selectivity = 1000
-> 약 10개의 row에 대해 city = 'SEOUL'을 찾으면 됨

하지만!!! 선택도가 높지 않다고 하더라도 정렬이나 grouping 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.

### § 8.3.3.4 읽어야 하는 레코드의 건수

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 든다.

테이블에 레코드가 100만 건 있는데, 50만 건을 읽어야 하는 쿼리가 있다고 가정해보자.
전체 테이블을 읽은 후, 50만 건을 버리는 것 <-> 인덱스를 이용해 50만 건만 읽어오는 것

중 어떤 것이 효율적인지 판단해야 한다.

일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것 보다 4~5배 비싸다고 예측한다.  
즉, 인덱스를 통해 읽어야 할 레코드의 건 수가 전체 테이블 레코드의 20~25%를 넘어서면 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식이 효율적이다.

## § 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### § 8.3.4.1 인덱스 레인지 스캔

인덱스를 통해 레코드를 한 건 이상 읽는 경우를 "인덱스 레인지 스캔" 이라고 표현하겠다.

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

![인덱스를 이용한 레인지 스캔](/Section.%208.1%20-%208.4/이주현/images/8.8.png)  
루트 노드에서 시작해 리프까지 찾아가야만 레코드의 시작점을 알 수 있다.  
이후에는 리프 노드의 다음 링크를 타고 타고 넘어갈 수 있다.  
<br>

---

<br>

![인덱스 레인지 스캔을 통한 데이터 레코드 읽기](/Section.%208.1%20-%208.4/이주현/images/8.9.png)  
<br>

---

<br>

#### 인덱스 레인지 스캔

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색(index seek)이라고 한다.

2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔(index scan)이라고 한다. (1번과 2번 합쳐서 인덱스 스캔으로 통칭하기도 한다.)

3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.

### § 8.3.4.2 인덱스 풀 스캔

쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 대표적으로 풀 스캔이 사용됨.

ex. 인덱스는 (A, B, C) 순서, 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우

![인덱스 풀 스캔](/Section.%208.1%20-%208.4/이주현/images/8.10.png)  
<br>

---

<br>

인덱스 레인지 스캔보다는 느리지만 테이블 풀 스캔 보다는 효율적이다.  
인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문

### 예시

| emp_id | name    | department | hire_date  |
| :----- | :------ | :--------- | :--------- |
| 1      | Alice   | HR         | 2020-01-01 |
| 2      | Bob     | Sales      | 2021-02-01 |
| 3      | Charlie | IT         | 2021-03-01 |
| ...    | ...     | ...        | ...        |

```sql
CREATE INDEX idx_department ON employees (department);
```

```sql
SELECT department FROM employees;
```

`department` 칼럼에만 인덱스가 걸려있음  
이후 부서만 조회하고 싶은 경우  
필요한 컬럼(department)가 인덱스 안에 포함되어 있으므로 테이블 접근이 필요 없음.

### § 8.3.4.3 루스 인덱스 스캔

![루스 인덱스 스캔(dept_name, first_name 칼럼은 참조용으로 표시됨)](/Section.%208.1%20-%208.4/이주현/images/8.11.png)  
<br>

---

<br>

(dept_no, emp_no) 에 인덱스가 걸려있고, 정렬되어 있음

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

dept_no 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다는 것을 옵티마이저가 알고있기 때문에  
필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어감.

### § 8.3.4.4 인덱스 스킵 스캔

```sql
ALTER TABLE employees
ADD INDEX ix_gender_birthdate (gender, birth_date);
```

이 인덱스를 사용하려면 gender 칼럼 비교 조건이 반드시 필요하다.

```sql
// 인덱스를 못써먹는 쿼리
SELECT * FROM employees WHERE birth_date>='1965-02-01';

// 인덱스 사용 가능 쿼리
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
```

하지만!!  
MySQL 8.0 버전부터 옵티마이저가 gender 칼럼을 건너뛰고 birth_date 칼럼만으로 인덱스 검색이 가능하게 해주는  
인덱스 스킵 스캔 기능이 도입되었다..

![인덱스 스킵 스캔](/Section.%208.1%20-%208.4/이주현/images/8.11.png)  
<br>

---

<br>
옵티마이저는 내부적으로 아래 2개의 쿼리를 실행한다.

```sql
SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
SELECT gender, birth_date FROM employees WHERE gender='F' AND birth_date>='1965-02-01';
```

인덱스 스킵 스캔을 사용하려면 아래와 같은 제약 조건이 필요하다..

1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 선택도가 낮아야 함.(예시에서는 'M', 'F' 2 였음)
2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

유니크한 값의 개수가 매우 많다면 쿼리의 처리 성능이 오히려 더 느려질 수도 있다.

## § 8.3.5 다중 칼럼(Multi-column) 인덱스

지금까지 살펴본 인덱스들은 모두 1개의 칼럼만 포함했다.  
하지만 실제 서비스용 데이터베이스에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다.

- 2개 이상의 칼럼으로 구성된 인덱스를 **다중 칼럼 인덱스**(복합 칼럼 인덱스)라고 한다.
- 또한 2개 이상의 칼럼이 연결됐다고 해서 **Concatenated Index**라고도 부른다.

![다중 칼럼 인덱스](/Section.%208.1%20-%208.4/이주현/images/8.13.png)

---

**정렬 기준**

- 인덱스의 첫 번째 칼럼에 **우선적으로** 의존하여 정렬한다.
- 같은 값이 있을 경우 두 번째 칼럼에 **의존**하여 정렬한다.
- 두 번째 칼럼의 값만으로는 독립적으로 레코드를 조회할 수 없다.
  - (첫 번째 칼럼이 고정되어야 의미를 가진다.)

**중요 포인트**

- 다중 칼럼 인덱스에서는 칼럼의 **순서**가 매우 중요하다.
- 인덱스를 생성할 때 컬럼의 순서를 신중히 결정해야 한다.
  - 첫 번째 칼럼을 기준으로 정렬
  - 같은 값에서는 두 번째 칼럼을 기준으로 추가 정렬
- 예시: `(dept_no, emp_no)` 인덱스
  - `dept_no`를 기준으로 정렬하고
  - 같은 `dept_no` 안에서 `emp_no`를 기준으로 정렬한다.

---

# § 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때는 칼럼별로 **오름차순**(ASC) 또는 **내림차순**(DESC) 정렬을 지정할 수 있다.  
쿼리에서는 인덱스를 읽는 **방향**에 따라 정렬 효과가 달라진다.

## § 8.3.6.1 인덱스의 정렬

일반적으로 인덱스 생성 시

- 오름차순(ASC)
- 내림차순(DESC)

으로 정렬 순서를 지정할 수 있다.

**MySQL 5.7 버전까지**

- 인덱스 생성 시 컬럼 단위로 ASC, DESC를 섞어 사용할 수 없었다.
- 모두 ASC이거나 모두 DESC이어야 했다.

**MySQL 8.0부터**

- 서로 다른 정렬 순서를 혼합해 인덱스를 만들 수 있다.

```sql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

---

## § 8.3.6.1.1 인덱스 스캔 방향

- 인덱스는 기본적으로 **오름차순**으로 정렬된다.
- 하지만 쿼리에서는 읽는 방향을 조정할 수 있다.

예시:

```sql
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```

- 인덱스를 역순으로 읽는다.
- 가장 큰 값을 빠르게 가져온다.

![인덱스의 오름차순(ASC)과 내림차순(DESC) 읽기](/Section.%208.1%20-%208.4/이주현/images/8.14.png)
<br>

---

<br>

### 인덱스 읽기 방향에 따른 특징

- 정순 읽기 (Forward index scan)

  - 키의 크기 증가 방향으로 인덱스를 읽는다.

- 역순 읽기 (Backward index scan)

  - 키의 크기 감소 방향으로 인덱스를 읽는다.

- MySQL 옵티마이저는 쿼리 실행 시 인덱스를 순방향/역방향으로 읽을지를 결정한다.
  - 필요 시 자동으로 역순으로 읽을 수 있다.

<br>

## § 8.3.6.2 내림차순 인덱스

MySQL 8.0부터는 명시적으로 내림차순 인덱스를 생성할 수 있다.

```sql
CREATE INDEX ix_firstname_asc ON employees (first_name ASC);
CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
```

- 내림차순 인덱스를 만들면 역순 스캔보다 약간 더 빠른 결과를 얻을 수 있다.

**특히 유리한 경우**

- 특정 컬럼에 대해 `ORDER BY 컬럼 DESC` 쿼리가 빈번할 때
- 인덱스의 앞/뒤로만 집중적으로 읽을 때

---

### 성능 비교

테스트 결과:

- 1,261만 건을 `ORDER BY tid ASC` vs `ORDER BY tid DESC`로 읽었을 때
  - 역순 스캔이 약 28.9% 더 느렸다.

**이유**

- InnoDB는 페이지(블록) 간 **양방향 연결**(double linked list) 구조를 사용하지만,
- 페이지 **내부**에서는 레코드들이 **단방향**으로만 연결되어 있기 때문에,
- 역순 스캔할 때 약간의 추가 비용이 발생한다.

![InnoDB 페이지 내에서 레코드들의 연결](/Section.%208.1%20-%208.4/이주현/images/8.16.png)

<br>  
---  
<br>

#### 정리

| 경우                  | 추천 인덱스     |
| :-------------------- | :-------------- |
| 주로 정순 조회 (ASC)  | 오름차순 인덱스 |
| 주로 역순 조회 (DESC) | 내림차순 인덱스 |

#### 참고

- 인덱스를 생성할 때 쿼리 패턴(ASC/ DESC 빈도)을 고려해 정렬 순서를 선택해야 한다.
- 자주 사용하는 방향에 맞춘 인덱스를 만드는 것이 성능 최적화에 유리하다.

<br>

## § 8.3.7 B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건, GROUP BY, ORDER BY 절에 대해  
어떤 경우에 인덱스를 사용할 수 있고,  
어떤 방식으로 사용하는지에 따라 성능에 차이가 발생한다.

### § 8.3.7.1 비교 조건의 종류와 효율성

다중 칼럼 인덱스에서는  
각 칼럼의 순서와 사용된 조건(=, >, <)에 따라 인덱스 활용 형태가 달라진다.

```sql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;
```

Case A: `INDEX(dept_no, emp_no)`  
Case B: `INDEX(emp_no, dept_no)`

- Case A 인덱스

  - `dept_no='d002'`를 먼저 확인한 후,  
    `emp_no >= 10114` 조건을 체크한다.
  - 조건을 만족하지 않으면 읽지 않고 건너뛸 수 있다.
  - 비교 작업이 최소화된다.

- Case B 인덱스
  - `emp_no >= 10114`를 먼저 찾은 후,
    레코드마다 `dept_no='d002'` 조건을 추가로 검사해야 한다.
  - 필요 없는 레코드도 읽어야 하므로 비효율적이다.

![인덱스 칼럼 순서로 인한 쿼리 실행 내역의 차이](/Section.%208.1%20-%208.4/이주현/images/8.17.png)

<br>

---

<br>

### § 8.3.7.2 인덱스의 가용성

B-Tree 인덱스는 왼쪽(Left-most) 값 기준으로 정렬되어 있다.  
다중 칼럼 인덱스에서도 왼쪽 칼럼 값을 알 수 있어야 인덱스 사용이 가능하다.

예시:

- Case A: `INDEX(first_name)`
- Case B: `INDEX(dept_no, emp_no)`

first_name 인덱스를 사용할 때

```sql
SELECT * FROM employees
WHERE first_name LIKE 'gmer';
```

- 조건이 `%gmer`처럼 접두사가 불명확할 경우, 인덱스를 사용할 수 없다.
- 왼쪽 값 기준 정렬 특성상, 처음부터 범위를 알 수 없는 경우 인덱스 레인지 스캔이 불가능하다.

dept_emp(emp_no, dept_no) 인덱스를 사용할 때

```sql
SELECT * FROM dept_emp
WHERE emp_no > 10144;
```

- emp_no만으로는 사용 가능.
- dept_no가 선행 칼럼이면 emp_no 조건만으로 인덱스를 사용할 수 없다.

<br>

### § 8.3.7.3 가용성과 효율성 판단

다음 조건들은 B-Tree 인덱스를 효율적으로 사용할 수 없다.

### 사용이 제한되는 경우

- **NOT-EQUAL** 비교

  ```sql
  WHERE column <> 'N'
  WHERE column NOT IN (10,11,12)
  WHERE column IS NOT NULL
  ```

- **LIKE** 패턴이 접두사가 아닌 경우

  ```sql
  WHERE column LIKE '%승환'
  ```

- **스토어드 함수 연산 결과 비교**

  ```sql
  WHERE SUBSTRING(column, 1, 1) = 'X'
  ```

- **NOT-DETERMINISTIC 함수 비교**

  ```sql
  WHERE column = some_function()
  ```

- **데이터 타입 변환 비교**

  ```sql
  WHERE char_column = 10
  ```

- **Collation이 다른 문자열 비교**
  ```sql
  WHERE utf8_bin_column = euckr_bin_column
  ```

---

#### 예외: NULL 값 비교

MySQL에서는 NULL 값도 인덱스에 저장된다.

```sql
WHERE column IS NULL
```

- 이 경우 인덱스를 사용할 수 있다.

---

#### 다중 칼럼 인덱스 사용 시 주의사항

`INDEX(column_1, column_2, ..., column_n)`

**인덱스를 사용할 수 없는 경우**

- 선행 칼럼(column_1)에 조건이 없는 경우
- column_i에서 부등호(> <) 비교가 발생한 후 뒤의 칼럼 조건

**예시**

```sql
-- 인덱스 사용 불가
WHERE column_1 <> 2;

-- 인덱스 사용 (column_1 = 값, column_2 > 값)
WHERE column_1 = 1 AND column_2 > 10;

-- 인덱스 사용 (column_1, column_2 = 값, column_3 >= 값)
WHERE column_1 = 1 AND column_2 = 2 AND column_3 >= 10;

-- 범위 조건 이후 다중 컬럼 체크
WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10,30) AND column_4 < 100;

-- 범위 조건 + LIKE 접미사 패턴
WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 30 AND column_4 LIKE '김승%';

-- 모든 컬럼 사용
WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30
AND column_4 = '김승환' AND column_5 = '서울';
```

작업 범위 결정 조건을 충족해야 효율적인 인덱스 사용이 가능하다.  
이 내용은 MySQL뿐만 아니라 대부분의 RDBMS에서도 동일하게 적용된다.
