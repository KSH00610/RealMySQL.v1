# Real MySQL 9.1 ~ 9.2

# 9.1 개요

- Intro
  - 옵티마이저 : 쿼리를 최적으로 실행하기 위해 비존 데이터 비교해 최적의 실행 계획 수립하는 역할 담당
- MySQL 쿼리 실행 절차
  1. SQL 문장을 잘게 쪼개 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) = SQL 파싱
     - MySQL이 이해하는 수준: 파스 트리(Parse Tree)
       1. SQL 문장 파싱 (Parsing) : 문법적으로 올바른지 검사하고 문장을 토큰 단위로 나눈 뒤 이를 파스 트리(parse tree, 구문 트리) 구조로 바꾼다.

          ```sql
          SELECT name FROM users WHERE age > 20;

          SELECT
          ├── Columns: name
          ├── FROM
          │   └── Table: users
          └── WHERE
              └── Condition: age > 20
          ```

       2. 파스트리 → 실행 계획 변환 : 옵티마이저가 테이블 스캔 방법, 인덱스 사용 여부, 조인 순서 등 결정
  2. SQL 파싱 정보(파스 트리) 확인하면서 어떤 테이블로부터 읽고 어떤 인덱스를 사용할지 선택한다.

     1. 불필요한 조건 제거 및 연산의 단순화
     2. 여러 테이블 조인 시 어떤 순서로 테이블 읽을지 결정
     3. 각 테이블에 사용된 조건과 인덱스 통계 정보 활용해 사용할 인덱스 결정
     4. 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야하는 결정

     ⇒ 최적화 및 실행 계획 수립 단계 : 옵티마이저에서 처리

  3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스 이용해 스토리지 엔진부터 데이터 가져옴
- 옵티마이저 종류
  1. 규칙 기반 최적화(Rule Based Optimizer, RBO) : 테이블 레코드 건수나 선택도 고려 않고 옵티마이저 내장된 우선 순위에 따라 실행 계획 수립 → 통계정보(테이블 레코드 건수 칼럼값 분포도)를 조사하지 않고 실행 계획 수립하기에 같은 쿼리는 거의 항상 같은 실행 방법으로 만듬
  2. 비용 기반 최적화(Cost Based Optimizer, CBO) : 여러 가능한 방법 중 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보로 실행 계획별 비용 산출이 최소인 처리 방식 채택

# 9.2 기본 데이터 처리

- Intro
  - 결과물이 동일해도 RDBMS 별로 결과 만드는 방식은 다양하다.
- 풀 테이블 스캔과 풀 인덱스 스캔
  1. 풀 테이블 스캔 : 인덱스 사용하지 않고 테이블 데이터 처음부터 끝까지 읽어서 요청된 작업 처리하는 방식
     - 테이블 레코드 건수 너무 작아 인덱스 읽는 것보다 풀 테이블 스캔하는게 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
     - WHERE 절이나 ON 절에 인덱스 이용할 수 있는 적절한 조건 없는 경우
     - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우
  - 일반적으로 테이블 전체 크기 >>>>> 인덱스 크기 → 테이블 처음부터 끝까지 읽는데 상당히 많은 디스크 읽기 필요 → DBMS 풀 테이블 스캔 시 한꺼번에 여러 개의 블록이나 페이지 읽어오는 기능 내장
  - Read ahead(리드 어헤드) : InnoDB 스토리지 엔진에서 특정 테이블의 연속된 데이터 페이지 읽는 경우 백그라운 스레드에서 어떤 영역 데이터가 앞으로 필요하다는 것을 예측해 요청 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것 의미 → 플 테이블 스캔 시 특정 시점부터 포그라운드 스레드가 아닌 백그라운드 스레드에서 읽기 작업 수행해 한 번에 4, 또는 8개씩 읽어 최대 64개까지 버퍼 풀에 저장, 프로그라운드 스레드는 미리 버퍼 풀에 적재된 것을 가져다 쓰는 것이므로 디스크로부터 읽기에 비해 빠른 속도로 처리
  - Read ahead는 풀 테이블 스캔뿐만 아니라 풀 인덱스 스캔에서도 사용, 풀 인덱스 스캔이란 인덱스 처리부터 끝까지 스캔하는 것 의미
    ```sql
    mysql> SELECT COUNT(*) FROM employees;

    -> 풀테이블 스캔을 할 것으로 보이지만, 단순 레코드의 건수만 필요한 것이므로 용량이 작은 인덱스 선택하는 것이 디스크 읽기 횟수 줄일 수 있다.
    -> 일반적으로 인덱스는 테이블의 2 ~ 3개의 컬럼으로 구성되기 때문에 용량이 작아서 훨씬 빠르게 처리

    mysql> SELECT * FROM employees;
    ->  레코드에만 있는 칼럼이 필요한 경우 풀 인덱스 스캔 활용 X
    ```
- 병렬 처리 : 하나의 쿼리를 여러 스레드가 작업 나누어 동시에 처리하는 것 의미, MySQL에서 WHERE 조건 없는 단순 테이블 전체 건수 가져오는 쿼리만 병렬 처리
  ```sql
  mysql> SET SESSION innodb_parallel_read_threads=1;
  mysql> SELECT COUNT(*) FROM employees;
  1 row in set(0.32 sec)

  mysql> SET SESSION innodb_parallel_read_threads=2;
  mysql> SELECT COUNT(*) FROM employees;
  1 row in set(0.20 sec)

  mysql> SET SESSION innodb_parallel_read_threads=4;
  mysql> SELECT COUNT(*) FROM employees;
  1 row in set(0.18 sec)

  mysql> SET SESSION innodb_parallel_read_threads=8;
  mysql> SELECT COUNT(*) FROM employees;
  1 row in set(0.13 sec)

  병렬 처리용 스레드 갯수가 늘어날 수록 쿼리 처리 소요 시간 감소 -> 병렬 스레드 갯수가 CPU 코어 갯수 넘어가는 순간 오히려 성능이 떨어질 수도 있다.
  ```
  - ORDER BY 처리(Using filesort)
    - What is filesort : ORDER BY 절이 쿼리에 포함되었지만 해당 정렬 조건을 만족하는 적절한 인덱스가 존재하지 않을 때 filesort 알고리즘으로 정렬, Using filesort는 정렬 대상 데이터를 메모리 또는 임시 파일에 저장
    - Filesort 정렬 방식
      1. 두 번 읽기 (Two-Pass) 방식
         - 정렬에 필요한 필드(정렬 키 + row ID)만 임시 메모리에 저장 후 정렬
         - 정렬 완료 후 row ID를 통해 테이블에서 전체 row를 다시 읽어 옴
         - I/O 두번 발생
      2. 한 번 읽기 (Single-Pass) 방식
         - 정렬에 필요한 모든 row 데이터를 임시 메모리에 저장하고 한 번에 정렬
         - I/O 한 번 발생하지만 메모리 사용량 많아짐
      - 데이터 정렬 방법
        | 데이터 정렬 방법 / 특성 | 장점                                                                                                      | 단점                                                                           |
        | ----------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
        | 인덱스 이용             | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 되므로 매우 빠름 | INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요해 느리다. |
        인덱스 때문에 디스크 공간이 더 필요하다.
        인덱스 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요 |
        | Filesort 이용 | 인덱스 생성하지 않아도 되므로 인덱스를 이용할 때 단점이 장점으로 바뀐다.
        정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |
      - Filesort 사용하는 이유 : 모든 정렬을 인덱스를 이용해 튜닝하기가 불가능하기 때문
        1. 정렬 기준이 너무 많아 요건별로 모두 인덱스를 생성하는게 불가능
        2. GROUP BY, DISTINCT 같은 처리 결과를 정렬해야하는 경우
        3. UNION 결과 같이 임시 테이블 결과를 다시 정렬해야하는 경우
        4. 랜덤하게 결과 레코드 가져와야하는 경우
      - 실행 계획의 Extra 컬럼에 “Using filesort” 메시지가 표시되는 여부로 확인 가능
    - 소트버퍼
      - 정의 : 정렬 수행하기 위해 받는 별도의 메모리 공간
      - 특징 : 정렬 필요한 경우 할당, 버퍼의 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가(최대 사용 가능 소트 버퍼 공간은 sort_buffer_size로 설정)
      - 문제점 1: 정렬해야할 레코드 건수 > 소트 버퍼 할당된 공간
        - 메모리 버퍼(sort_buffer_size)에 모든 정렬 대상 레코드를 담을 수 없으면, MySQL은 정렬 데이터를 여러 조각(chunk) 으로 나눕니다.
        - 각 조각은 디스크의 임시 파일에 저장되고, 최종적으로 병합 정렬(Multi-merge) 수행 시 다시 디스크에서 읽음
        - 결과적으로 디스크 쓰기 및 읽기 I/O가 크게 증가 → 성능 저하
      - 문제점 2 : 소프버퍼는 세션(로컬) 메모리 영역
        - 커넥션 즉 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐 → 소트 버퍼의 크기를 10MB 이상으로 설정 시 대량 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시 실행되면서 OS는 메모리 부족 현상
    - 정렬 알고리즘
      - 정의 : 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 싱글 패스(Single-pass)와 투 패스(Two-pass)로 나뉨
      - MySQL 정렬 방식
        1. <sort_key, rowid> : 정렬 키와 레코드의 로우 아이디만 가져와 정렬하는 방식
        2. <sort_key, additional_fields> : 정렬 키와 레코드 전체 가져와 정렬하는 방식, 레코드 컬럼들은 고정 사이즈로 메모리 저장
        3. <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와 정렬하는 방식, 레코드 컬럼들은 가변 사이즈로 메모리 저장

           → 첫 번째 방식을 “투 패스” 정렬 방식, 두 번째와 세 번째 방식을 “싱글 패스” 방식이라고 명명
        - 싱글 패스 정렬 방식 : 소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상 컬럼 전부 담아 정렬 수행하는 방식
          ```sql
          mysql> SELECT emp_no, first_name, last_name FROM employees ORDER BY first_name;

          -> employees 테이블 읽을 때 정렬 필요하지 않은 last_name까지 전부 읽어 소트 버퍼에 담고 정렬 수행
          -> 정렬 성능이 나빠질 수 있는 경우
          ---> SELECT * 처럼 모든 컬럼을 포함하거나, TEXT, BLOB, VARCHAR(긴 길이) 등 가변 길이 필드가 포함되어 버퍼 공간이 빨리 소진되는 경우
          ---> 이때 버퍼를 초과하면 임시 파일을 디스크에 생성하여 정렬 → Using temporary; Using filesort 발생
          ```
        - 투 패스 정렬 방식 : 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블 읽어 SELECT할 컬럼 가져오는 정렬 방식
          ```sql
          mysql> SELECT emp_no, first_name, last_name FROM employees ORDER BY first_name;

          -> employees 테이블 읽을 때 정렬에 필요한 first_name 컬럼과 프라이머리 키 emp_no만 읽어 정렬 수행
          ---> 레코드의 크기가 max_length_for_sort_data 시스템 변수 설정된 값보다 클 때
          ---> BLOB, TEXT 타입 컬럼이 SELECT 대상에 포함된 경우
          ---> 여전히 원 패스가 아닌 투 패스 정렬 방식 활용
          ```
    - 정렬 처리 방법(아래로 갈 수록 처리 속도 떨어짐)
      | 정렬 처리 방법                                  | 실행 계획의 Extra 칼럼 내용                     |
      | ----------------------------------------------- | ----------------------------------------------- |
      | 인덱스 사용한 정렬                              | 별도 표기 없음                                  |
      | 조인에서 드라이빙 테이블만 정렬                 | “Using filesort” 메시지 표시됨                  |
      | 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | “Using temporary; Using filesort” 메시지 표시됨 |
      - 절차
        1. 옵티마이저는 정렬 처리 위해 인덱스 이용하는지 검토
        2. 만약 인덱스 이용할 수 있다면, 별도의 Filesort 과정 없이 인덱스 순서대로 읽어 결과 변환 / 인덱스를 이용할 수 없다면 WHERE 조건에 일치하는 레코드 검색해 정렬 버퍼에 저장하면서 정렬 처리(Filesort), 옵티마이저는 정렬 대상 레코드 최소화해야된다.
           1. 조인 드라이빙 테이블만 정렬한 다음 조인 수행
           2. 조인 끝나고 일치하는 레코드 모두 가져온 후 정렬 수행
      - 인덱스 이용한 정렬
        - 정의
          - 인덱스 이용할 정렬 위해 ORDEY BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용될 경우 드라이빙 테이블)에 속하고 ORDER BY 순서와 맞는 인덱스가 존재해야한다.
          - WHERE 절에 첫 번째로 읽는 테이블 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
          - B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등은 인덱스를 이용한 정렬 사용 X (+ R-Tree도 B-Tree 계열이지만 인덱스를 이용할 정렬 사용 X)
          - 여러 테이블 조인되는 경우 네스티드-루프(Nested-loop) 방식의 조인에서만 사용 가능
        - 인덱스 이용해 정렬 처리되는 경우 : 실제 인덱스의 값이 정렬되어 있기에 순서대로 읽기만 하면됨 → 추가적인 정렬을 위한 작업 X
          ```sql
           mysql>  SELECT *
          				 FROM employees e, salaries s
          				 WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10020
          				 ORDER BY e.emp_no;

           mysql>  SELECT *
          				 FROM employees e, salaries s
          				 WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10020;

          	-> emp_no가 기본 키이므로 기본적으로 클러스터링 인덱스로 구성되어 있기에 기본키로 오름 차순 정렬이 되어 있다.
          	-> ORDER BY 사용여부와 관계없이 같은 결과 변환
          	-> ORDER BY를 쓰게되면 추가적인 정렬 즉 여기서는 불필요한 정렬 작업이 발생하는가?, No 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬 작업 수행하지 않는다.
          ```
        - 조인의 드라이빙 테이블 정렬
          - 정의 : 조인 수행 시 결과 레코드의 건수가 몇 배로 불어나고 레코드 하나하나의 크기도 늘어난다. → 조인 실행 전 첫 번째 테이블 레코드 먼저 정렬 후 조인 실행하는게 정렬 차선책
            ```sql
             mysql>  SELECT *
            				 FROM employees e, salaries s
            				 WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10020
            				 ORDER BY e.last_name;

            -> WHERE 절이 다음 2가지 조건을 갖추고 있다.
            	-> 1. WHERE 절 검색 조건(e.emp_no BETWEEN 10002 AND 10020)은 employees 테이블의 프라이머리 키 이용해 검색 시 작업량 줄일 수 있다.
            	-> 2. 드리븥 테이블(salaries)의 조인 컬럼인 emp_no 컬럼에 인덱스가 있다.
            ```
          - 절차
            1. 인덱스를 이용해 “e.emp_no BETWEEN 10002 AND 10020” 에 해당하는 9건 검색
            2. 검색 결과를 last_name 컬럼으로 정렬 수행(Filesort)
            3. 정렬 결과 순서대로 읽으면서 salaries 테이블과 조인 수행해 86건 결과 가져옴
        - 임시 테이블을 이용한 정렬
          - 정의 : 2개 이상 테이블 조인해 결과 정렬 시 임시 테이블 필요할 수 있다. “조인의 드라이빙 테이블만 정렬” 2개 이상 테이블이 조인되면서 정렬 실행되지만 임시 테이블 사용되지 않음 But 그 외 패턴 쿼리에서는 항상 조인 결과 임시 테이블에 저장하고 결과 다시 정렬하는 과정 거침
            ```sql
             mysql>  SELECT *
            				 FROM employees e, salaries s
            				 WHERE s.emp_no = e.emp_no AND e.emp_no BETWEEN 10002 AND 10020
            				 ORDER BY s.salary;

            -> 전과 달리 정렬 기준 컬럼이 드라이빙 테이블(employees)가 아니라 드리븐 테이블(salaries)에 위치, 조인된 데이터로 정렬 해야된다. 조인 전에 정렬 불가
            ---> Extra 컬럼에 "Using temporary; Using filesort" 표시, 이는 조인 결과를 임시 테이블 저장 후 그 결과 다시 정렬 처리
            ```
        - 정렬 처리 방법
          1. 스트리밍 방식
             - 레코드를 한 번에 다 모아서 정렬/가공 후 결과 반환하는 것이 아니라, 조건에 맞는 레코드를 찾자마자 바로바로 클라이언트에게 전송하는 방식
             - 결과를 점진적으로 전송(streaming) 하므로, 클라이언트는 처음 몇 개의 결과를 즉시 받아 가공 작업을 병렬로 수행 가능
               | 항목                | 스트리밍 방식                                             |
               | ------------------- | --------------------------------------------------------- |
               | 데이터 처리 방식    | 조건 일치 시 즉시 클라이언트로 전송                       |
               | 메모리 사용         | 낮음 (전체 결과를 버퍼에 담지 않음)                       |
               | 응답 시간           | 빠름 (처리 즉시 전송)                                     |
               | LIMIT 등 적용       | 매우 효율적 → 불필요한 전 레코드 읽기 방지                |
               | 정렬(ORDER BY) 사용 | 제약 있음 → 정렬 필요 시 전체 수집 후 처리(스트리밍 불가) |
               | 클라이언트 가공     | 빠르게 시작 가능 (비동기 처리처럼 동작)                   |
             - 스트리밍 방식 비활성되는 경우
               1. ORDER BY, GROUP BY, DISTINCT 사용
               2. UNION, SUBQUERY, FILESORT 포함 쿼리
               3. 정렬 위해 임시 테이블 생성해야 하는 경우
               4. JOIN 후 결과 정렬 필요한 경우
               → 이 경우 MySQL 결과 전체를 내부 버퍼에 수집하고, 정렬/집계 등을 한 이후 한 번에 클라이언트로 전송
          2. 버퍼링 방식

             - 모든 결과 레코드를 메모리(혹은 임시 테이블)에 먼저 수집한 후,
               정렬/가공을 마친 뒤 클라이언트에게 한 번에 전송하는 방식
             - 쿼리 처리 중간에는 클라이언트는 응답을 받지 못함 → 처리 완료 후 응답
               | 항목                | 버퍼링 방식                                |
               | ------------------- | ------------------------------------------ |
               | 데이터 처리 방식    | 모든 결과를 내부 버퍼에 수집 후 전송       |
               | 메모리 사용         | 높음 (모든 레코드를 저장)                  |
               | 응답 시간           | 늦음 (완료 후 일괄 전송)                   |
               | LIMIT 등 적용       | 효율 떨어짐 (모든 결과 조회 후 제한 적용)  |
               | 정렬(ORDER BY) 사용 | 가능 (전체 수집 후 정렬 수행)              |
               | 클라이언트 가공     | 늦게 시작 (결과가 전부 도착한 뒤에야 가능) |
             - 버퍼링 방식 강제되는 경우
               1. ORDER BY, GROUP BY, DISTINCT 존재 : 정렬 또는 집계 연산 위해 전체 데이터 수집
               2. UNION, SUBQUERY, FILESORT 포함 쿼리 : 내부적으로 정렬과 병합이 필요
               3. 정렬 위한 임시 테이블 생성 필요 : 메모리 임시 테이블 생성 시 전체 데이터 로딩
               4. 조인 결과를 정렬해야 할 경우 : 조인된 결과가 정렬 대상인 경우 정렬 전까지 결과 보낼 수 없음

             ```sql
             mysql>  SELECT *
             				FROM tb_test1 t1, tb_test2 t2
             				WHERE t1.col1=t2.col1
             				ORDER BY t1.col2
             				LIMIT 10;

             ---> tb_test1 테이블의 레코드가 100건, tb_test2 테이블의 레코드가 1000건(tb_test의 레코드 1건당 tb_test2의 레코드가 10건씩 존재한다는 가정)
             ---> 두 테이블의 조인 결과는 전체 1000건이라고 가정
             ```

             - tb_test1이 드라이빙되는 경우
               | 정렬 방법       | 읽어야할 건수  | 조인 횟수 | 정렬해야 할 대상 건수                     | 상세 설명 |
               | --------------- | -------------- | --------- | ----------------------------------------- | --------- |
               | 인덱스 사용     | tb_test1 : 1건 |
               | tb_test2 : 10건 | 1번            | 0건       | 전제 : tb_test1.col2에 인덱스가 걸려있다. |
               처리 방식
               1. MySQL은 t1.col2 인덱스를 이용해 정렬된 순서로 tb_test1을 탐색
               2. 첫 번째 레코드를 찾음 (tb_test1 : 1건 읽음)
               3. 이 레코드의 col1 값으로 tb_test2에서 조인 조건에 맞는 10건 조회
               4. 조인된 결과 10건이 생성됨 → LIMIT 10 만족 → 쿼리 종료
                  → 따라서 tb_test1은 1건만 읽고도 원하는 10건 조인 결과를 만들 수 있어서 더 이상 읽지 않음 |
                  | 조인의 드라이빙 테이블만 정렬 | tb_test1 : 100건
                  tb_test2 : 10건 | 1번 | 100건
                  (tb_test1 테이블의 레코드 건수만큼 정렬 필요) | 전제 : tb_test1.col2에 인덱스가 없고, 정렬 조건이 tb_test1.col2 기준으로 설정
                  처리 방식
               5. tb_test1 전체(100건)를 먼저 읽어서 메모리(또는 임시 테이블)에 정렬
               6. 정렬된 tb_test1 레코드를 차례로 탐색하면서 tb_test2와 조인
               7. 정렬은 드라이빙 테이블(tb_test1)만 하므로 부하가 크지 않지만 읽는 건수가 많을수록 정렬 비용 증가 → 정렬 대상이 tb_test1 전체라면, 메모리 사용량 및 성능에 영향 줄 수 있음 |
                  | 임시 테이블 사용 후 정렬 | tb_test1 : 100건
                  tb_test2 : 1000건 | 100번
                  (tb_test1 테이블의 레코드 건수만큼 조인 발생) | 1000건
                  (조인된 결과 레코드 건수를 전부 정렬해야 함) | 전제 : 정렬 조건이 조인 결과 컬럼에 포함되어 있고 해당 컬럼에 인덱스 없음
                  처리 방식
               8. tb_test1의 100건에 대해 tb_test2와 조인 수행 → 총 100번 조인 → 결과적으로 1000건 생성
               9. LIMIT 또는 ORDER BY 조건 만족하기 위해 조인 결과 전체를 임시 테이블 저장 3.저장된 임시 테이블 다시 정렬 → 정렬 대상이 조인된 결과 전체(1000건)가 됨 → 이 방식은 읽기 건수가 많고, 정렬 대상도 많아 비용도 가장 크며 성능 저하 가능성 높음 |
             - tb_test2이 드라이빙되는 경우
               | 정렬 방법       | 읽어야할 건수   | 조인 횟수 | 정렬해야 할 대상 건수                                            | 상세 설명 |
               | --------------- | --------------- | --------- | ---------------------------------------------------------------- | --------- |
               | 인덱스 사용     | tb_test1 : 10건 |
               | tb_test2 : 10건 | 10번            | 0건       | 전제 : tb_test2.col2 등에 정렬 조건 있고 해당 컬럼에 인덱스 걸림 |
               처리 방식
               1. MySQL은 tb_test2 테이블에서 정렬 조건이 적용된 인덱스를 이용해 정렬된 순서로 탐색
               2. 정렬 없이 인덱스 스캔으로 바로 원하는 순서로 레코드 추출 가능
               3. 각 tb_test2 레코드마다 tb_test1과 조인 수행(총 10번) → 인덱스를 이용해 정렬 대상 0건, 효율적이고 빠른 처리 가능 |
                  | 조인의 드라이빙 테이블만 정렬 | tb_test1 : 1000건
                  tb_test2 : 10건 | 10번 | 100건
                  (tb_test2 테이블의 레코드 건수만큼 정렬 필요) | 전제 : tb_test2의 정렬 조건 컬럼에 인덱스 없음
                  처리 방식
               4. tb_test2를 정렬 조건에 따라 정렬 → 10건 정렬
               5. 정렬된 순서대로 각 tb_test2 레코드에 대해 tb_test1과 조인 수행
               6. 각 조인 결과가 10건씩 나왔다면 → 총 100건 조인 결과가 생김 → 정렬 tb_test2의 드라이빙 대상에만 적용되며 조인 후 결과 100건 |
                  | 임시 테이블 사용 후 정렬 | tb_test1 : 1000건
                  tb_test2 : 100건 | 1000번
                  (tb_test2 테이블의 레코드 건수만큼 조인 발생) | 1000건
                  (조인된 결과 레코드 건수를 전부 정렬해야 함) | 전제 : 정렬 조건이 조인된 결과 컬럼(tb_test.col3)에 있으며 인덱스 없음
                  처리 방식
               7. tb_test2가 드라이빙 테이블이지만 정렬 조건에 맞게 정렬 불가(인덱스 없음)
               8. 각 tb_test1 레코드마다 tb_test2 100건과 조인 시도 → 총 1000건 결과 생성
               9. 이 조인 결과를 모두 임시 테이블 저장 후 ORDER BY 조건으로 정렬 시도 → 정렬 대상이 전체 결과 1000건로 커지며 임시 테이블 사용으로 인해 메모리 및 디스크 I/O 비용 증가정렬 관련 상태 변수 |
  - GROUP BY 처리 : 스프리밍된 처리 불가, GROUP BY 에 사용된 조건은 인덱스 사용해 처리할 수 없으므로 HAVING 절 튜닝하려고 인덱스 생성하거나 다른 방법 고민할 필요 X

    - 인덱스 사용하는 경우
      1. 인덱스 스캔 이용(타이트 인덱스 스캔) : 인덱스를 정렬된 순서로 읽으며 바로 GROUP BY 수행
         1. 조건 : GROUP BY에 사용된 컬럼이 **인덱스의 맨 앞부터 순서대로 포함**되어 있어야 함
         2. 특징
            - 임시 테이블 사용 없이 인덱스만으로 그루핑 가능
            - 정렬 작업 없이 효율적으로 집계
         3. 예시

            ```sql
            mysql> SELECT col1, COUNT(*) FROM table GROUP BY col1;
            ```

            - 만약 INDEX(col1)가 있다면 → 타이트 인덱스 스캔 사용 가능
      2. 루스 인덱스 스캔 이용 : 인덱스의 특정 키만 건너뛰며 읽는 방식
         1. 조건 : GROUP BY에 사용하는 컬럼이 중간 인덱스 컬럼이어도 가능
         2. 예시

            ```sql
            mysql> EXPLAIN
            					SELECT emp_no
            					FROM salaries
            					WHERE from_date='1985-03-01'
            					GROUP BY emp_no;

            -|----|----------|--------|--------|-----------------------------------------|
            |  id | table    | type   | key    | Extra                                   |
            -|----|----------|--------|--------|-----------------------------------------|
            |  1 | salaries  | range  | PRIMARY| Using where; Using index for group-by   |
            -|----|----------|--------|--------|-----------------------------------------|
            ```

            - salaries 테이블의 인덱스는 (emp_no, from_date)로 생성되 있어 위의 쿼리 문장에서 WHERE 조건은 인덱스 렝니지 스캔 접근 방식으로 이용 못함 but 쿼리 실행 계획은 다음과 같이 인덱스 레인지 스캔(range 타입) 이용, Extra 컬럼 메시지 보면 GROUP BY 처리까지 인덱스 사용

         3. 절차
            1. (emp_no, from_date) 인덱스를 차례로 스캔하며 emp_no의 첫번째 유일 값(그룹 키) “10001”을 찾아낸다.
            2. (emp_no, from_date) 인덱스에서 emp_no가 “10001” 인 것 중 from_date가 “1985-03-01”인 레코드만 가져온다. 이 검색법은 1 단계에서 알아낸 “10001”과 쿼리의 WHERE 절에 사용된 from_date = “1985-03-01” 조건을 합쳐서 “emp_no = 10001 AND from_date = ‘1985-03-01’” 조건으로 (emp_no, from_date) 인덱스를 검색한 것과 흡사
            3. (emp_no, from_date) 인덱스에서 emp_no의 그 다믐 유니크(그룹 키) 값 가져온다.
            4. 3단계에서 결과 더 없으면 처리 종료, 결과 있으면 2번으로 반복
    - 인덱스 사용하지 못하는 경우
      1. 임시 테이블을 사용하는 GROUP BY

         ```sql
         mysql> EXPLAIN
         					SELECT e.last_name, AVG(s.salary)
         					FROM employees e, salaries s
         					WHERE e.emp_no = s.emp_no
         					GROUP BY e.last_name;

         -|----|----------|--------|--------|----------|--------------------------------|
         |  id | table    | type   | key    | rows     | Extra                          |
         -|----|----------|--------|--------|----------|--------------------------------|
         |  1  | e        | ALL    | NULL   | 300584   | Using temporary                |
         -|----|----------|--------|--------|----------|--------------------------------|
         |  1  | s        | ref    | PRIMARY| 10       | NULL                           |
         -|----|----------|--------|--------|----------|--------------------------------|
         ```

  - DISTINCT 처리
    - SELECT DISTINCT : 레코드 중에서 유니크한 레코드만 가져올 떄 사용 → GROUP BY와 동일하게 처리
      - 주의점 : DISTINCT는 SELECT하는 레코드(튜플)를 유니크하게 SELECT하는 것, 특정 칼럼만을 유니크하게 조회하는 것 아님
        ```sql
        mysql> SELECT DISTINCT first_name, last_name FROM employees;

        ---> first_name만 유니크하게 가져오는게 아니라 (first_name, last_name) 조합 전체를 유니크하게 가져옴
        ```
    - 집합 함수 + DISTINCT
      - SELECT에서 DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 값들을 반환 but 집합 함수 내에서 사용된 DISTINCT는 집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들만 가져옴
        ```sql
        mysql> EXPLAIN SELECT COUNT(DISTINCT s.salary)
        			 FROM employees e, salaries s
        			 WHERE e.emp_no = s.emp_no
        			 AND e.emp_no BETWEEN 100001 AND 100010

        -|----|----------|--------|--------|----------|--------------------------------|
        |  id | table    | type   | key    | rows     | Extra                          |
        -|----|----------|--------|--------|----------|--------------------------------|
        |  1  | e        | range  | PRIMARY| 100      | Using where; Using index       |
        -|----|----------|--------|--------|----------|--------------------------------|
        |  1  | s        | ref    | PRIMARY| 10       | NULL                           |
        -|----|----------|--------|--------|----------|--------------------------------|

        ---> 이 쿼리는 내부적으로 COUNT를 처리하기 위해 임시 테이블 사용 nut 실행 계획에는 임시 테이블 사용한 메시지 표시 X
        ---> 버그처럼 보이지만 MySQL 서버에서 보여주는 실행 계획에서 "Using temporary"를 표시하지 않고 있다.
        ---> employees 테이블과 salaries 테이블 조인 결과에서 salary 칼럼의 값만 저장하기 위해 임시 테이블 사용 -> 유니크 인덱스가 생성되기에 레코드 건수 많아진다면 상당히 느려짐

        mysql> SELECT COUNT(DISTINCT s.salary), COUNT(DISTINCT e.last_name)
        			 FROM employees e, salaries s
        			 WHERE e.emp_no = s.emp_no
        			 AND e.emp_no BETWEEN 100001 AND 100010
        -|----|----------|--------|--------|----------|--------------------------------|
        |  id | table    | type   | key    | rows     | Extra                          |
        -|----|----------|--------|--------|----------|--------------------------------|
        |  1  | e        | range  | PRIMARY| 100      | Using where; Using index       |
        -|----|----------|--------|--------|----------|--------------------------------|
        |  1  | s        | ref    | PRIMARY| 10       | NULL                           |
        -|----|----------|--------|--------|----------|--------------------------------|

        ---> COUNT(DISTINCT ...) 하나 추가했어도 실행 계획은 똑같이 표시 But s.salary 칼럼의 값 저장할 임시 테이블과 e.last_name 칼럼 값 저장할 임시 테이블 총 2개 필요

        mysql> SELECT COUNT(DISTINCT emp_no) FROM employees;
        mysql> SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
        -|----|----------|--------|--------|----------|--------------------------------|
        |  id | table    | type   | key    | rows     | Extra                          |
        -|----|----------|--------|--------|----------|--------------------------------|
        |  1  | dept_emp | index  | PRIMARY| 331143   | Using index                    |
        -|----|----------|--------|--------|----------|--------------------------------|

        ---> 인덱스된 칼럼에 대해 DISTINCT 처리 시 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행
        ```
  - 내부 임시 테이블 활용
    - 개요 : MySQL이 GROUP BY, ORDER BY, DISTINCT, UNION, 파생 테이블, 뷰 처리 등을 수행할 때 내부적으로 생성하는 일회성 임시 테이블(서버 내부 연산 적용) → 내부적이란 : CREATE TEMPORARY TABLE 명령으로 만든 임시 테이블과 다름
      - 일반적인 MySQL 엔진이 사용하는 임시 테이블 : 처음 메모리에 생성 후 테이블 크기 커지면 디스크로 옮김(메모리 거치지 않고 디스크에 바로 임시 테이블 만들어지는 경우도 존재)
      - MySQL 내부적 가공을 위해 생성한 임시 테이블 : 다른 세션이나 쿼리에서 볼 수 없고 사용도 불가 + 쿼리의 처리가 완료되면 자동으로 삭제
    - 메모리 임시 테이블 vs 디스크 임시 테이블
      | 상황                         | 설명                                                                          |
      | ---------------------------- | ----------------------------------------------------------------------------- |
      | 메모리 기반 임시 테이블 생성 | 쿼리 결과가 작고 열 타입이 단순하면 메모리에 TempTable 엔진으로 생성          |
      | 디스크 기반 임시 테이블 전환 | 쿼리 결과가 크거나 BLOB/TEXT 등 복잡한 타입 사용 시 디스크에 InnoDB 테이블 생 |
      | 구분      | 메모리 임시 테이블 | 디스크 임시 테이블                          |
      | --------- | ------------------ | ------------------------------------------- |
      | 저장 위치 | 메모리 (RAM)       | 디스크 (InnoDB 스토리지)                    |
      | 엔진      | TempTable          | InnoDB                                      |
      | 전환 조건 | 기본 사용 대상     | 아래 조건 중 하나라도 만족 시 디스크로 전환 |
      1. 결과 집합 크기가 tmp_table_size 또는 max_heap_table_size 초과
      2. SELECT 대상에 BLOB, TEXT, JSON 등 컬럼 포함
      3. 문자열 길이가 512 바이트 이상
      4. UNION 연산 사용
      5. 쿼리 내 정렬 대상 컬럼 수가 많은 경우 |
         | 전환 트리거 | 결과 크기가 tmp*table_size or max_heap_table_size 초과 BLOB, TEXT, JSON 컬럼 포함 정렬 대상 열의 길이가 너무 길 때 등 | 항상 디스크 사용 |
         | 성능 | 빠름 (낮은 I/O 부하) | 느림 (디스크 I/O 발생) |
         | 특징 | 단순 연산에 적합 | 복잡한 정렬/그룹핑 시 사용, 느리지만 처리 가능 |
         | 생성 시점 | 내부적으로 필요할 때 자동 생성 | 자동 전환 또는 직접 디스크에 생성될 수도 있음 |
         | 확인 방법 | EXPLAIN의 Using temporary 또는 SHOW STATUS LIKE ‘Created_tmp*%’로 추적 가능 | |
    - 임시테이블이 필요한 쿼리
      1. ORDER BY와 GROUP BY에 명시된 컬럼이 다른 쿼리
      2. ORDER BY나 GROUP BY에 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
      3. DISTINCT와 ORDER BY가 동시에 뭐리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
      4. UNION나 UNION DISTINCT 사용된 쿼리 (select_type 컬럼이 UNIION RESULT인 경우)
      5. 쿼리의 실행 계획에서 select+type이 DERIVED 쿼리
      - 마지막 3개의 패턴은 Using temporary 표시되지 않아도 임시 테이블 사용
      - 첫 번째부터 네 번째까지 유니크 인덱스 가지는 내부 임시 테이블 생성 마지막 쿼리 패턴은 유니크 인덱스가 없는 내부 임시 테이블 생성
    - 임시 테이블이 디스크에 생성되는 경우
      1. UNION이나 UNION ALL에서 SELECT 되는 컬럼 중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 경우
      2. GROUP BY나 DISTINCT 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
      3. 메모리 임시 테이블의 크기나 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 (TempTable 스토리지 엔진에서) temptable_max_ram 시스템 변수 값보다 큰 경우
    - 임시 테이블 관련 상태 변수 : 실행 계획에서 Using temporary 표시되면 임시 테이블 사용한 사실 알 수 있다. But 임시 테이블이 메모리에서 처리됐는지 디스크에서 처리됐는지는 모르며 몇 개의 임시 테이블이 사용됐는지도 알 수 없다.
      - SHOW SESSION STATUS LIKE ‘Created_tmp%’ : 임시 테이블이 디스크에 생성되었는지 메모리에 생성되었는지 확인 가능
      - FLUSH STATUS : 현재 세션 상태 초기화 → 테스트 쿼리 실행 전에 수행
      - Created_tmp_tables : 쿼리 처리를 위해 만들어진 내부 임시 테이블의 갯수 누적하는 상태 값, 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지 구분하지 않는다.
      - Created_tmp_disk_tables : 디스크 내부 임시 테이블 만들어진 갯수만 누적
