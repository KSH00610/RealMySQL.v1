# 9.1 개요

## 9.1.1 쿼리 실행 절차

쿼리 실행 절차는 크게 3단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보를 확인하며, 어떤 테이블로부터 읽고 인덱스를 사용해 테이블을 읽을 지 선택한다.
3. 두 번째 단계에서 결정된 읽기 순서나 인덱스를 이용해서 스토리지 엔진으로부터 데이터를 가져온다.

**첫 번째 단계**를 `SQL 파싱`이라 하며, `SQL 파서`라는 모듈로 처리한다. 문법적인 오류는 이 단계에서 걸러지며, 결과로 `SQL 파스 트리가 만들어진다.`

**두 번째 단계**는 `최적화 및 실행 계획 수립`이며, SQL 파스 트리를 통해 다음 내용을 처리한다.

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블 조인이 있는 경우 어떤 순서로 읽을 지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보로 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 한 번 더 가공 여부 결정

**세 번째 단계**는 수립된 실행 계획대로 실제 요청하고 작업을 수행한다.

## 9.1.2 옵티마이저의 종류

크게 비용 기반 최적화 방법(CBO)과 규칙 기반 최적화 방법(RBO)으로 나눌 수 있다.

규칙 기반 최적화(RBO)는 기본적으로 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다. 이 때 통계 정보등을 조사하지 않기에 같은 쿼리에 대해 같은 실행 방법을 만들어낸다.

비용 기반 최적화(CBO)는 쿼리를 처리하기 위해 여러 가지 방법을 만들고 가장 낮은 비용의 방식을 선택한다. 현재는 **대부분의 DBMS가 비용 기반 옵티마이저를 채택**하고 있으며 MySQL도 동일하다.

## 실습: MySQL은 CBO가 맞구나

책을 읽다가 인덱스를 너무 태워보고 싶어서 지금 개발하고 있는 프로젝트의 `users.user_name`에 색인을 걸고 정렬 조회를 해봤다.

> 💡 **Note:** 테이블 정보  
> 해당 테이블엔 레코드가 24개 들어있는 아주 작은 테이블이다.

**쿼리 1**

```sql
EXPLAIN SELECT * FROM users ORDER BY user_name;
```

**풀 테이블 스캔이 발생**했다. 색인 자체가 제대로 생성되지 않았나 하여, 다음 쿼리도 실행해보았다.

**쿼리 2**

```sql
EXPLAIN SELECT * FROM users WHERE user_name = '테스트계정';
```

결과는 **ref 스캔이 발생**하였다. ref는 비유니크 인덱스 또는 유니크 인덱스의 일부만 사용하는 경우에 발생하는 접근 방식으로, 쉽게 말해 **인덱스로 여러 개의 행을 찾지만 조건 컬럼이 정해져 있는 경우** 발생하는 스캔이다.

결론적으로 인덱스는 제대로 생성되었고, 인덱스도 잘 탄다라는 것을 확인할 수 있다.

### 그렇다면? 쿼리 1은 왜 인덱스를 타지 않았을까?

결론적으로 말하면 MySQL은 CBO 방식으로 **풀 테이블 스캔 후 정렬을 하는 것이 풀 인덱스 스캔 후 랜덤 I/O를 작동시키는 것보다 비용이 더 저렴하다고 판단**했기 때문이라고 생각해볼 수 있을 것 같다.

만약 MySQL이 RBO였다면 무조건 인덱스를 태우지 않았을까?

### 인덱스를 강제로 태우는 방법

쿼리 1을 다음과 같이 수정하면 인덱스를 강제로 태울 수 있다.

**쿼리 3**

```sql
SELECT * FROM users FORCE INDEX (users_user_name_index) ORDER BY user_name;
```

지금은 레코드가 현저히 적어서(24줄), 네트워크 I/O 속도의 영향을 너무 많이 받아서 응답 속도에 대한 큰 의미가 없다.
