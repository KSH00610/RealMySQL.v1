# 옵티마이저와 힌트

# § 9.1 쿼리 실행 절차와 옵티마이저의 종류

## § 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리, 파스 트리를 생성한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정
3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

## § 9.1.2 옵티마이저의 종류

1. 규칙 기반 최적화 방법(Rule-based optimizer, RBO)  
   대상 테이블의 레코드 수나 선택도를 고려하지 않음.  
   같은 쿼리에 대해서는 거의 같은 실행 방법을 만들어낸다.

2. 비용 기반 최적화(Cost-based optimizer, CBO)  
   쿼리를 처리할 수 있는 여러 가지 방법을 만들고, 각 단위 작업의 부하 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획 별 비용을 산출한다.  
   비용이 최소인 처리 방식을 선택한다.

# § 9.2 데이터 처리

## § 9.2.1 풀 테이블 스캔 & 풀 인덱스 스캔

MySQL 옵티마이저는 다음과 같은 조건에서 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건 수가 너무 적어서 인덱스를 이용하는 것보다 풀 테이블 스캔을 하는 것이 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있더라도 조건 일치 레코드 건 수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 만든 통계 정보 기준)

### 리드 어헤드

MyISAM에서는 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어오지만,
InnoDB에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read Ahead) 작업이 수행된다.  
요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 둠.

풀 테이블 스캔이 수행되면 몇 새의 데이터 페이지는 포그라운드 스레드가, 일정 개 수 이상 부터는 백그라운드 스레드가 수행한다. `innodb_read_ahead_threshold` 변수로 조절 가능

read ahead는 풀 인덱스 스캔에서도 동일하게 사용된다.

## § 9.2.2 병렬 처리

`innodb_parallel_read_threads` 시스템 변수를 잉요해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할 지 설정할 수 있다.  
하지만 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU 코어 개수를 넘어가면 오히려 성능이 떨어질 수 있다.

## § 9.2.3 ORDER BY 처리(Using filesort)

정렬을 처리하는 방법

### 1. 인덱스 이용

인덱스가 이미 정렬되어 있으므로 순서대로 읽으면 된다.
INSERT, UPDATE, DELETE 시에 인덱스 처리로 인해 느리다. 디스크 공간이 더 필요하다. InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다.

### 2. Filesort 이용

인덱스를 생성하지 않아도 되므로 INSERT, UPDATE, DELETE가 빠르고 메모리를 적게 사용할 수 있다.  
정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건 수가 많아질수록 쿼리의 응답 속도가 느려진다.

filesort가 사용되는 경우

- 정렬 기준이 너무 많아서 요건 별로 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 결과를 정렬하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는경우

### § 9.2.3.1 소트 버퍼

정렬을 수행하기 위해 시스템으로부터 MySQL이 할당 받는 별도의 메모리 공간  
`sort_buffer_size` 변수로 최대 크기를 조절 가능  
쿼리의 실행이 완료되면 즉시 시스템으로 반환됨.

#### 정렬해야 할 레코드가 할당된 공간보다 큰 경우

레코드들을 여러 조각으로 나눠서 처리, 디스크에 임시 저장, 다시 병합  
이 병합 작업을 멀티 머지(Multi-merge)라고 부름.

소트 버퍼의 크기를 키우면 멀티 머지가 줄어드므로 디스크 접근이 줄어 빨라지지만, 너무 큰 `sort_buffer_size`는 큰 메모리 공간 할당으로 이어져 성능이 오히려 떨어질 수 있다.

### § 9.2.3.2 정렬 알고리즘

#### 1. <sort_key, rowid> 정렬 키와 로우 아이디만 가져와서 정렬하는 방식

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬,  
 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 칼럼을 가져옴. (테이블을 두 번 읽어야 함)

![](/Section.%209.1%20-%209.2/이주현/images/9.3.png)  
<br>

---

<br>

#### 2. <sort_ke, additional_fields(packed_additional_fields)> 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정(가변) 사이즈로 메모리에 저장됨.

![](/Section.%209.1%20-%209.2/이주현/images/9.2.png)  
<br>

---

<br>
최신 버전에서는 일반적으로 싱글 패스 방식을 사용하지만,

- 레코드의 크기가 `max_length_for_sort_data` 보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

투 패스 정렬을 사용하게 된다.

### § 9.2.3.3 정렬 처리 방법

쿼리에 ORDER BY 가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 된다.

1. 인덱스를 사용한 정렬
2. 조인에서 드라이빙 테이블만 정렬
3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬

## § 9.2.4 GROUP BY 처리

GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성할 필요는 없다.

### § 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY

ORDER BY와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 grouping 할 때, GROUP BY 칼럼에 인덱스가 있다면, 그 인덱스를 차례대로 읽으면서 grouping 작업을 수행하고, 그 결과로 조인을 수행.

### § 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY

### § 9.2.4.3 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 칼럼이 인덱스를 전혀 사용하지 못하는 경우

## § 9.2.5 DISTINCT 처리

## § 9.2.6 내부 임시 테이블 활용
