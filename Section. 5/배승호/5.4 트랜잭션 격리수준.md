# 트랜잭션 격리 수준 (Isolation Level)

트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정한다. 트랜잭션의 격리 수준은 다음과 같은 네 가지 단계가 있다.

1. **SERIALIZABLE**  
   SERIALIZABLE은 가장 엄격한 격리 수준으로, 트랜잭션을 순차적으로 진행시킨다. 여러 트랜잭션이 동일한 레코드에 동시에 접근할 수 없으므로 어떠한 데이터 부정합 문제도 발생하지 않는다. 그러나 트랜잭션을 순차적으로 처리해야 하므로 동시 처리 성능이 매우 떨어진다.  
   MySQL에서 SELECT FOR SHARE/UPDATE는 대상 레코드에 각각 읽기/쓰기 잠금을 건다. 하지만 순수한 SELECT 작업은 일반적으로 잠금 없이 실행된다. 다만 SERIALIZABLE에서는 순수 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유 락, Shared Lock)으로 건다. 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다. SERIALIZABLE은 안전하지만 성능이 떨어지므로 극단적으로 안전한 작업이 필요할 때만 사용한다.

2. **REPEATABLE READ**  
   REPEATABLE READ는 트랜잭션 내에서 동일한 데이터를 조회할 때 항상 동일한 결과를 보장한다. 이를 위해 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)를 사용한다.  
   MySQL의 REPEATABLE READ에서는 새로운 레코드가 추가되더라도 기존 데이터를 다시 조회할 때 동일한 결과를 반환한다. 다만 SELECT FOR UPDATE나 SELECT FOR SHARE와 같은 잠금 읽기를 사용하면 MVCC 대신 테이블 데이터를 참조하게 되어 유령 읽기(Phantom Read)가 발생할 수 있다. 그러나 MySQL은 갭 락을 사용해 이러한 유령 읽기를 방지한다. MySQL에서는 일반적으로 REPEATABLE READ 수준에서 팬텀 읽기가 거의 발생하지 않는다.  
   REPEATABLE READ는 MySQL의 기본 격리 수준으로, 높은 정합성을 유지하면서도 성능을 적절히 보장한다.

3. **READ COMMITTED**  
   READ COMMITTED는 커밋된 데이터만을 조회할 수 있는 격리 수준이다.  
   이 수준에서는 Non-Repeatable Read(반복 읽기 불가능) 문제가 발생할 수 있다. 예를 들어, 한 트랜잭션이 처음에 조회한 데이터가 다른 트랜잭션에서 커밋된 후 다시 조회했을 때 다른 결과를 반환할 수 있다. READ COMMITTED는 커밋된 데이터만 허용하므로 데이터의 정합성이 낮아지는 경우가 있다.  
   일반적인 데이터 조회 작업에는 READ COMMITTED가 적합하나, 데이터의 정합성을 유지해야 하는 중요한 작업에는 적합하지 않다.

4. **READ UNCOMMITTED**  
   READ UNCOMMITTED는 커밋되지 않은 데이터도 조회할 수 있는 가장 낮은 격리 수준이다.  
   이 수준에서는 Dirty Read(오손 읽기)가 발생할 수 있다. 예를 들어, 한 트랜잭션이 데이터를 수정하고 커밋하지 않았음에도 다른 트랜잭션이 해당 데이터를 볼 수 있다.  
   만약 트랜잭션이 롤백된다면, 다른 트랜잭션에서 조회했던 데이터가 사라지는 현상이 발생한다. 이러한 Dirty Read 문제는 시스템에 큰 혼란을 초래할 수 있다.  
   READ UNCOMMITTED는 일반적으로 사용되지 않으며, 최소한 READ COMMITTED 이상의 격리 수준을 사용하는 것이 좋다.
