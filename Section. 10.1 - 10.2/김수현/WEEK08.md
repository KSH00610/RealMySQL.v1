# Real MySQL 10.1 ~ 10.2

# 10.1 통계 정보

- Intro
  - MySQL 8.0부터 인덱스되지 않은 컬럼들에 대해서도 데이터 분포도 수집해서 저장하는 히스토그램 정보 도입 + 기존의 테이블이나 인덱스 통계 정보 또한 제공
- 테이블 및 인덱스 통계 정보
  - 비용 기반 최적화에서 가장 중요한 것 = 통계 정보
  - MySQL은 비용 기반 최적화 사용 But 통계 정보의 정확도 높지 않고 휘발성이 강함 → 쿼리 실행 계획 수립 시 실제 테이블의 데이터 일부 분석해 통계 정보 보완해 사용
    - MySQL 5.6부터 통계정보를 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리 → 이를 통해 MySQL 서버 재시작되어도 기존 통계 정보 유지 가능 + STATS_PERSISTENT 옵션으로 테이블 단위 영구적 통계 정보 보관 여부 결정(기본적으로 ON)
  - MySQL 5.5까지 통계정보가 메모리에만 저장(휘발성) → 서버 재시작 시 통계정보 초기화 But 5.6버전부터 영구적인 통계 정보가 도입되며 의도치 않은 통계 정보 변경 방지
  - 테이블 통계 정보 수집 시에 innodb_stats_transient_sample_pages와 innodb_stats_persistent_sample_pages 활용
    1.  innodb_stats_transient_sample_pages : 자동으로 통계 정보 수집 실행 시 8개 페이지 임의로 샘플링해 분석하고 그 결과를 통계 정보로 활용(기본값 8)
    2.  innodb_stats_persistent_sample_pages : ANALYZE TABLE 명령 실행 시 임의로 20개 페이지만 샘플링해 분석해 그 결과 영구적인 통계 정보 테이블에 저장 후 활용(기본값 20)
  - innodb_stats_persistent_sample_pages의 값이 커진다면 더 정확한 통계 정보 수집되지만 그만큼 정보 수집 시간이 길어지므로 적절히 값을 설정해라
- 히스토그램
  - MySQL 8.0에서 히스토그램 정보는 컬럼 단위로 관리 → ANALYZE TABLE … UPDATE HISTOGRAM 명령을 실행해 수동으로 수집 및 관리
  - MySQL 서버 시작 시 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드 → column_statistics 테이블 SELECT해서 참조 가능
  - Bucket : 히스토그램에서 레코드 건수나 칼럼 값의 범위 관리하는 단위
  - MySQL 8.0에서 지원하는 히스토그램 타입
    | 구분 | Singleton Histogram | Equi-Height Histogram |
    | --------- | ------------------------------------- | ------------------------------------------------ |
    | 별칭 | Value-Based Histogram(도수 분포) | Height-Balanced Histogram |
    | 버킷 기준 | 컬럼 **값 개별**로 버킷 할당 | **값의 범위**를 갯수가 균등하게 나누어 버킷 할당 |
    | 버킷 정보 | - 컬럼의 값- 해당 값의 발생 빈도 비율 | - 시작 값- 끝 값- 빈도율- 유니크 값 수 |
    | 특징 | 각 컬럼 값마다 빈도 추적**값 중심** | 값의 분포를 균등하게 나눔**범위 중심** |
  - 히스토그램 삭제 작업은 테이블 데이터 참조하는 것이 아닌 딕셔너리 내용만 삭제하기에 다른 쿼리 처리의 성능에 영향 주지 않고 즉시 완료
    ```sql
    mysql>  ANALYZE TABLE employees.employees
    				DROP HISTOGRAM ON gender, hire_date
    ```
  - optimizer_switch 옵션 값으로 히스토그램 삭제하지 않고 옵티마이저가 히스토그램 사용하지 못하게 한다.
  - 히스토그램 용도 : 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지 않지만 각 범위(버킷) 별로 레코드 건수와 유니크 값의 개수 정보를 갖기에 훨씬 정확한 예측 가능 → 기존에는 테이블 전체 레코드 건수와 인덱스된 컬럼이 가지는 유니크 값의 갯수만 통계 정보로 존재
    - 히스토그램 정보 없으면 옵티마이저는 데이터가 균등하게 분포할 것으로 예측 But 히스토그램 존재로 특정 범위 데이터 많고 적음 식별 가능 → 이를 통해 쿼리 성능에 큰영향을 미친다, 히스토 그램 정보를 통해 어떤 테이블 먼저 읽어야 조인 횟수를 줄일 수 있는지 옵티마이저가 정확히 판단 가능
  - 히스토그램과 인덱스 : 서로 다른 객체이기에 비교 대상은 아니지만
- 코스트 모델(Cost Model)
  - 개념 : 쿼리 처리 시 레코드 평가, 인덱스 키 비교 등 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용 계산한 결과 바탕으로 최적의 실행 모델 찾는데 필요한 단위 작업들의 비용
  - 문제점 : MySQL 5.7 이전까지 서버 소스 코드에 상수화했으나 하드웨어에 따라 달라질 수 있다 즉 고정된 비용을 일률적으로 적용하는 것은 최적의 실행 계획 수립에 방해 요소
  - 해결책 : MySQL 5.7 이후부터 상수화 → DBMS 관리자 조정 가능케 했다. + MySQL 8.0버전부터 컬럼 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용
  - MySQL 8.0 서버의 코스트 모델 설정 값 사용하는 테이블
    1. server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
    2. engine_cost : 레코드 가진 데이터 페이지를 가져오는데 필요한 비용 관리
    - 공통 컬럼
      1. cost_name : 코스트 모델의 각 단위 작업
      2. default_value : 각 다윈 작업 비용(기본값이며, 이 값은 MySQL 서버 소스 코드에 설정된 값)
      3. cost_value : DBMS 관리자가 설정한 값(이 값이 NULL이면 MySQL 서버는 default_value 값 사용)
      4. last_updated : 단위 작업 비용이 변경된 시점
      5. comment : 비용에 대한 추가 설명
    - engine_cost 에 추가적인 2개 컬럼
      1. engine_name : 비용이 적용된 스토리지 엔진
      2. device_cost : 디스크 타입
         cf) row_evaluatie_cost는 server_cost의 cost_name 중 하나로 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가하는 작업 단위 → 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드 처리하는 쿼리 비용 높아지고 레인지 스캔과 같이 상대적으로 적은 수 레코드 처리하는 쿼리 비용 낮아짐
         cf) key_compare_cost는 server_cost의 cost_name 중 하나로 키 값의 비교 작업에 필요한 비용 의미하는데 값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리 비용 높아짐
  - 각 단위 작업 비용 이용해 MySQL 서버 실행 계획에 표시되는 비용 직접 계산은 어렵다 → 인덱스 B-Tree 깊이, 인덱스 키 검색을 위해 읽어야하는 페이지 갯수 등의 정보가 필요한데 이런 정보들이 사용자에게 모두 표시되지 않기 때문
  - 코스토 모델에서 중요한 것 = 각 단위 작업 설정된 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 것이 저비용으로 바뀌는지 파악하는 것

# 10.2 실행 계획 확인

- Intro
  - DESC, EXPLAIN 명령으로 MySQL 서버 실행 계획 확인 가능
- 실행 계획 출력 포멧
  - MySQL 8.0부터 PARTITIONS, EXTENDED 옵션 문법에서 제거되어 모든 내용 통합되어 보임 + FORMAT 옵션으로 실행 계획 표시법을 JSON, TREE, 단순 테이블 중 선택 가능
- 쿼리 실행 시간 확인
  - MySQL 8.0부터 쿼리 실행 계획과 단계별 소요 시간 정보 확인하는 EXPLAIN ANALYZE 기능 추가
    | | EXPLAIN ANALYZE | SHOW PROFILE |
    | ------ | --------------------------------------------- | ----------------------------------------------- |
    | 공통점 | 어떤 부분에서 많이 시간이 소요되었는지 확인 | 어떤 부분에서 많이 시간이 소요되었는지 확인 |
    | 차이점 | 실행 계획의 단계별 소요된 시간 정보 조회 가능 | 실행 계획의 단계별 소요된 시간 정보 조회 불가능 |
  - EXPLAIN ANALYZE는 항상 TREE 포멧으로 결과 보여주기에 FORMAT 옵션 사용 불가능
  - EXPLAIN ANALYZE에서 들여쓰기는 호출 순서 의미
    - 들여쓰기 같은 레벨에서는 상단에 위치한 라인 먼저 실행
    - 들여쓰기 다른 레벨에서는 가장 안쪽에 위치한 라인 먼저 실행
